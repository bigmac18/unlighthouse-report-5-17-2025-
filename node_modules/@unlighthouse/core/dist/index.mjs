import { Buffer } from 'node:buffer';
import { createHash } from 'node:crypto';
import dns from 'node:dns';
import http from 'node:http';
import https from 'node:https';
import path, { dirname, resolve, join, basename, isAbsolute } from 'node:path';
import axios from 'axios';
import fs, { pathExists, ensureDirSync } from 'fs-extra';
import sanitize from 'sanitize-filename';
import slugify from 'slugify';
import { withTrailingSlash, withLeadingSlash, $URL, normalizeURL, withoutTrailingSlash, hasProtocol, withBase, isRelative, withQuery, joinURL, withoutLeadingSlash } from 'ufo';
import fs$1, { existsSync, readFileSync } from 'node:fs';
import { loadConfig } from 'c12';
import { colorize, box as box$1 } from 'consola/utils';
import { createDefu, defu } from 'defu';
import { createHooks } from 'hookable';
import { resolve as resolve$2, createCommonJS, resolvePath } from 'mlly';
import objectHash from 'object-hash';
import { $fetch } from 'ofetch';
import { createContext } from 'unctx';
import { pick, groupBy, map, sampleSize, sumBy, uniqBy, sortBy, get as get$1 } from 'lodash-es';
import { createConsola } from 'consola';
import os, { homedir } from 'node:os';
import { Cluster } from 'puppeteer-cluster';
import { computeExecutablePath, install, detectBrowserPlatform } from '@puppeteer/browsers';
import { Launcher } from 'chrome-launcher';
import puppeteer, { launch as launch$1 } from 'puppeteer-core';
import { PUPPETEER_REVISIONS } from 'puppeteer-core/lib/cjs/puppeteer/revisions.js';
import wrapAnsi from 'wrap-ansi';
import { WebSocketServer } from 'ws';
import { toRouteMatcher, createRouter } from 'radix3';
import { createUnrouted, redirect, prefix, post, get, useQuery, setStatusCode, useParams } from '@unrouted/core';
import { presetApi } from '@unrouted/preset-api';
import { presetNode, serve } from '@unrouted/preset-node';
import launch from 'launch-editor';
import { resolve as resolve$1, relative } from 'pathe';
import { parse } from 'regexparam';
import Sitemapper from 'sitemapper';
import { computeMedianRun } from 'lighthouse/core/lib/median-run.js';
import { load } from 'cheerio';

const version = "0.16.3";

function createScanMeta() {
  const { worker } = useUnlighthouse();
  const data = worker.reports().filter((r) => r.tasks.inspectHtmlTask === "completed");
  const reportsWithScore = data.filter((r) => r.report?.score);
  const score = reportsWithScore.map((r) => r.report.score).reduce((s, a) => s + a, 0) / reportsWithScore.length || 0;
  return {
    favicon: data?.[0]?.seo?.favicon,
    monitor: worker.monitor(),
    routes: data.length || 0,
    score
  };
}

async function generateClient(options = {}, unlighthouse) {
  const logger = useLogger();
  if (!unlighthouse)
    unlighthouse = useUnlighthouse();
  const { runtimeSettings, resolvedConfig, worker } = unlighthouse;
  let prefix = withTrailingSlash(withLeadingSlash(resolvedConfig.routerPrefix));
  if (prefix === "/") {
    prefix = "";
  }
  const clientPathFolder = dirname(runtimeSettings.resolvedClientPath);
  await fs.copy(clientPathFolder, runtimeSettings.generatedClientPath);
  const inlineScript = `window.__unlighthouse_static = ${options.static}`;
  let indexHTML = await fs.readFile(runtimeSettings.resolvedClientPath, "utf-8");
  indexHTML = indexHTML.replace(/<script data-unlighthouse-inline>.*?<\/script>/gs, `<script data-unlighthouse-inline>${inlineScript}<\/script>`).replace(/(href|src)="\/assets\/(.*?)"/g, `$1="${prefix}assets/$2"`);
  await fs.writeFile(resolve(runtimeSettings.generatedClientPath, "index.html"), indexHTML, "utf-8");
  const staticData = {
    reports: [],
    scanMeta: createScanMeta(),
    // need to be selective about what options we put here to avoid exposing anything sensitive
    options: pick({
      ...runtimeSettings,
      ...resolvedConfig
    }, [
      "client",
      "site",
      "websocketUrl",
      "lighthouseOptions",
      "scanner",
      "routerPrefix",
      "websocketUrl",
      "apiUrl"
    ])
  };
  staticData.options.lighthouseOptions = { onlyCategories: resolvedConfig.lighthouseOptions.onlyCategories };
  if (options.static) {
    staticData.reports = worker.reports().map((r) => {
      return {
        ...r,
        // avoid exposing user paths
        artifactPath: ""
      };
    });
  }
  await fs.writeFile(
    join(runtimeSettings.generatedClientPath, "assets", "payload.js"),
    `window.__unlighthouse_payload = ${JSON.stringify(staticData)}`,
    { encoding: "utf-8" }
  );
  const globby = await import('globby');
  const clientAssetsPath = join(dirname(runtimeSettings.resolvedClientPath), "assets");
  const indexFile = (await globby.globby(["index.*.js"], { cwd: clientAssetsPath }))?.[0];
  if (indexFile) {
    const indexPath = join(clientAssetsPath, indexFile);
    let indexJS = await fs.readFile(indexPath, "utf-8");
    indexJS = indexJS.replace('const base = "/";', `const base = window.location.pathname;`).replace('createWebHistory("/")', `createWebHistory(window.location.pathname)`);
    await fs.writeFile(indexPath.replace(clientPathFolder, runtimeSettings.generatedClientPath), indexJS, "utf-8");
  } else {
    logger.warn(`Failed to find index.[hash].js file from wd ${clientAssetsPath}.`);
  }
}

const AppName = "Unlighthouse";
const ClientPkg = "@unlighthouse/client";
const DefaultColumns = {
  "overview": [
    {
      label: "Screenshot Timeline",
      key: "report.audits.screenshot-thumbnails",
      cols: 6
    }
  ],
  "performance": [
    {
      cols: 1,
      label: "FCP",
      tooltip: "First Contentful Paint marks the time at which the first text or image is painted. [Learn more about the First Contentful Paint metric](https://developer.chrome.com/docs/lighthouse/performance/first-contentful-paint/).",
      key: "report.audits.first-contentful-paint",
      sortKey: "numericValue"
    },
    {
      cols: 2,
      label: "LCP",
      tooltip: "Largest Contentful Paint marks the time at which the largest text or image is painted. [Learn more](https://web.dev/lighthouse-largest-contentful-paint/)",
      key: "report.audits.largest-contentful-paint",
      sortKey: "numericValue"
    },
    {
      cols: 2,
      label: "CLS",
      tooltip: "Cumulative Layout Shift measures the movement of visible elements within the viewport.",
      sortKey: "numericValue",
      key: "report.audits.cumulative-layout-shift"
    },
    {
      cols: 1,
      label: "FID",
      warning: true,
      tooltip: "Warning: This is deprecated in favour if INP which is not yet supported by Unlighthouse. The maximum potential First Input Delay that your users could experience is the duration of the longest task. [Learn more](https://web.dev/lighthouse-max-potential-fid/).",
      sortKey: "numericValue",
      key: "report.audits.max-potential-fid"
    },
    {
      cols: 1,
      label: "TBT",
      tooltip: "Sum of all time periods between FCP and Time to Interactive, when task length exceeded 50ms, expressed in milliseconds. [Learn more](https://web.dev/lighthouse-total-blocking-time/).",
      sortKey: "numericValue",
      key: "report.audits.total-blocking-time"
    },
    {
      cols: 1,
      label: "SI",
      sortKey: "numericValue",
      tooltip: "The speed index is a page load performance metric that shows you how quickly the contents of a page are visibly populated. [Learn more](https://web.dev/speed-index/).",
      key: "report.audits.speed-index"
    }
  ],
  // accessibility
  "accessibility": [
    {
      cols: 3,
      label: "Color Contrast",
      tooltip: "Background and foreground colors do not have a sufficient contrast ratio.",
      sortKey: "length:details.items",
      key: "report.audits.color-contrast"
    },
    {
      cols: 1,
      label: "Headings",
      tooltip: "Heading elements appear in a sequentially-descending order",
      sortKey: "length:details.items",
      key: "report.audits.heading-order"
    },
    {
      cols: 1,
      label: "ARIA",
      tooltip: "An aggregate of all ARIA audits.",
      sortKey: "displayValue",
      sortable: true,
      key: "report.computed.ariaIssues"
    },
    {
      cols: 1,
      label: "Labels",
      tooltip: "Form elements have associated labels",
      sortKey: "length:details.items",
      key: "report.audits.label"
    },
    {
      cols: 1,
      label: "Image Alts",
      tooltip: "Image elements have [alt] attributes",
      sortKey: "length:details.items",
      key: "report.audits.image-alt"
    },
    {
      cols: 1,
      label: "Link Names",
      tooltip: "Links do not have a discernible name",
      sortKey: "length:details.items",
      key: "report.audits.link-name"
    }
  ],
  // best practices
  "best-practices": [
    {
      cols: 2,
      label: "Errors",
      tooltip: "No browser errors logged to the console",
      sortKey: "length:details.items",
      key: "report.audits.errors-in-console"
    },
    {
      cols: 2,
      label: "Inspector Issues",
      tooltip: "No issues in the `Issues` panel in Chrome Devtools",
      sortKey: "length:details.items",
      key: "report.audits.inspector-issues"
    },
    {
      cols: 2,
      label: "Images Responsive",
      tooltip: "Serves images with appropriate resolution",
      sortKey: "length:details.items",
      key: "report.audits.image-size-responsive"
    },
    {
      cols: 2,
      label: "Image Aspect Ratio",
      tooltip: "Displays images with correct aspect ratio",
      sortKey: "length:details.items",
      key: "report.audits.image-aspect-ratio"
    }
  ],
  // seo
  "seo": [
    {
      cols: 1,
      label: "Indexable",
      tooltip: "Page isn\u2019t blocked from indexing",
      key: "report.audits.is-crawlable"
    },
    { cols: 1, label: "Internal link", sortable: true, key: "seo.internalLinks" },
    { cols: 1, label: "External link", sortable: true, key: "seo.externalLinks" },
    // TODO replace
    {
      cols: 2,
      label: "Description",
      key: "seo.description"
    },
    {
      cols: 2,
      label: "Share Image",
      key: "seo.og.image"
    }
  ]
};
const defaultConfig = {
  routerPrefix: "/",
  apiPrefix: "/api",
  cache: true,
  client: {
    /**
     * By default try and group routes by the definition name, if no definition is found this will resolve
     * to the route.path.
     */
    groupRoutesKey: "route.definition.name",
    columns: DefaultColumns
  },
  scanner: {
    customSampling: {},
    ignoreI18nPages: true,
    maxRoutes: 200,
    skipJavascript: true,
    samples: 1,
    throttle: true,
    crawler: true,
    dynamicSampling: 8,
    sitemap: true,
    robotsTxt: true,
    device: "mobile"
  },
  // @ts-expect-error provided by server package, may not be provided in CI mode
  server: {
    port: 5678,
    showURL: false,
    open: true
  },
  discovery: {
    supportedExtensions: ["vue", "md"],
    pagesDir: "pages"
  },
  root: process.cwd(),
  outputPath: ".unlighthouse",
  debug: false,
  puppeteerOptions: {},
  puppeteerClusterOptions: {
    monitor: true,
    workerCreationDelay: 500,
    retryLimit: 3,
    timeout: 5 * 60 * 1e3,
    // wait for up to 5 minutes.
    // max concurrency is the amount of cpu cores we have
    maxConcurrency: Math.max(os.cpus().length - 1, 1),
    skipDuplicateUrls: false,
    retryDelay: 2e3,
    // Important, when using Lighthouse we want browser isolation.
    concurrency: Cluster.CONCURRENCY_BROWSER
  },
  lighthouseOptions: {
    onlyCategories: ["performance", "accessibility", "best-practices", "seo"]
  }
};

const loggerCtx = createContext();
function createLogger(debug = false) {
  const logger = createConsola().withTag(AppName);
  if (debug) {
    logger.level = 4;
  }
  loggerCtx.set(logger);
  return logger;
}
const useLogger = () => {
  let logger = loggerCtx.use();
  if (!logger)
    logger = createLogger();
  return logger;
};

async function fetchRobotsTxt(site) {
  site = new $URL(site).origin;
  const unlighthouse = useUnlighthouse();
  const logger = useLogger();
  logger.debug(`Scanning ${site}/robots.txt`);
  const robotsTxt = await fetchUrlRaw(
    `${site}/robots.txt`,
    unlighthouse.resolvedConfig
  );
  if (!robotsTxt.valid || !robotsTxt.response) {
    logger.warn("You seem to be missing a robots.txt.");
    return false;
  }
  logger.debug("Found robots.txt");
  return robotsTxt.response.data;
}
function matches(pattern, path) {
  const pathLength = path.length;
  const patternLength = pattern.length;
  const matchingLengths = Array.from({ length: pathLength + 1 }).fill(0);
  let numMatchingLengths = 1;
  let p = 0;
  while (p < patternLength) {
    if (pattern[p] === "$" && p + 1 === patternLength) {
      return matchingLengths[numMatchingLengths - 1] === pathLength;
    }
    if (pattern[p] === "*") {
      numMatchingLengths = pathLength - matchingLengths[0] + 1;
      for (let i = 1; i < numMatchingLengths; i++) {
        matchingLengths[i] = matchingLengths[i - 1] + 1;
      }
    } else {
      let numMatches = 0;
      for (let i = 0; i < numMatchingLengths; i++) {
        const matchLength = matchingLengths[i];
        if (matchLength < pathLength && path[matchLength] === pattern[p]) {
          matchingLengths[numMatches++] = matchLength + 1;
        }
      }
      if (numMatches === 0) {
        return false;
      }
      numMatchingLengths = numMatches;
    }
    p++;
  }
  return true;
}
function matchPathToRule(path, _rules) {
  let matchedRule = null;
  const rules = _rules.filter(Boolean);
  const rulesLength = rules.length;
  let i = 0;
  while (i < rulesLength) {
    const rule = rules[i];
    if (!matches(rule.pattern, path)) {
      i++;
      continue;
    }
    if (!matchedRule || rule.pattern.length > matchedRule.pattern.length) {
      matchedRule = rule;
    } else if (rule.pattern.length === matchedRule.pattern.length && rule.allow && !matchedRule.allow) {
      matchedRule = rule;
    }
    i++;
  }
  return matchedRule || {
    pattern: "",
    allow: true
  };
}
function mergeRobotsTxtConfig(config, { groups, sitemaps }) {
  config.scanner._robotsTxtRules = groups.filter((group) => {
    return group.userAgent.includes("*") || group.userAgent.includes(String(config.lighthouseOptions?.emulatedUserAgent));
  }).flatMap((group) => group._rules);
  if (config.scanner.sitemap !== false && sitemaps.length) {
    if (!Array.isArray(config.scanner.sitemap) || !config.scanner.sitemap.length)
      config.scanner.sitemap = [.../* @__PURE__ */ new Set([...Array.isArray(config.scanner.sitemap) ? config.scanner.sitemap : [], ...sitemaps])];
  }
}

const DYNAMIC_ROUTE_REGEX = /^\/[:*]/;
function getRoutePathExtension(key) {
  if (key === "_")
    return "*";
  if (key.startsWith("_"))
    return `:${key.substring(1)}`;
  return key;
}
function sortRoutes(routes) {
  routes.sort((a, b) => {
    if (!a.path.length)
      return -1;
    if (!b.path.length)
      return 1;
    if (a.path === "/")
      return DYNAMIC_ROUTE_REGEX.test(b.path) ? -1 : 1;
    if (b.path === "/")
      return DYNAMIC_ROUTE_REGEX.test(a.path) ? 1 : -1;
    let i;
    let res = 0;
    let y = 0;
    let z = 0;
    const _a = a.path.split("/");
    const _b = b.path.split("/");
    for (i = 0; i < _a.length; i++) {
      if (res !== 0)
        break;
      y = _a[i] === "*" ? 2 : _a[i].includes(":") ? 1 : 0;
      z = _b[i] === "*" ? 2 : _b[i].includes(":") ? 1 : 0;
      res = y - z;
      if (i === _b.length - 1 && res === 0) {
        res = _a[i] === "*" ? -1 : _a.length === _b.length ? a.path.localeCompare(b.path) : _a.length - _b.length;
      }
    }
    if (res === 0) {
      res = _a[i - 1] === "*" && _b[i] ? 1 : _a.length === _b.length ? a.path.localeCompare(b.path) : _a.length - _b.length;
    }
    return res;
  });
  routes.forEach((route) => {
    if (route.children)
      sortRoutes(route.children);
  });
  return routes;
}
function createRoutes(options) {
  const {
    files,
    srcDir,
    pagesDir = "",
    routeNameSplitter = "-",
    supportedExtensions = ["vue", "js"],
    trailingSlash
  } = options;
  const routes = [];
  files.forEach((file) => {
    const keys = file.replace(new RegExp(`^${pagesDir}`), "").replace(new RegExp(`\\.(${supportedExtensions.join("|")})$`), "").replace(/\/{2,}/g, "/").split("/").slice(1);
    const route = { name: "", path: "", component: resolve$1(srcDir, file) };
    let parent = routes;
    keys.forEach((key, i) => {
      const sanitizedKey = key.startsWith("_") ? key.substr(1) : key;
      route.name = route.name ? route.name + routeNameSplitter + sanitizedKey : sanitizedKey;
      route.name += key === "_" ? "all" : "";
      route.chunkName = file.replace(new RegExp(`\\.(${supportedExtensions.join("|")})$`), "");
      const child = parent.find((parentRoute) => parentRoute.name === route.name);
      if (child) {
        child.children = child.children || [];
        parent = child.children;
        route.path = "";
      } else if (key === "index" && i + 1 === keys.length) {
        route.path += i > 0 ? "" : "/";
      } else {
        route.path += `/${normalizeURL(getRoutePathExtension(key))}`;
        if (key.startsWith("_") && key.length > 1)
          route.path += "?";
      }
    });
    {
      route.pathToRegexpOptions = { ...route.pathToRegexpOptions, strict: true };
      route.path = withoutTrailingSlash(route.path);
    }
    parent.push(route);
  });
  sortRoutes(routes);
  return cleanChildrenRoutes(routes, false, routeNameSplitter, trailingSlash);
}
function cleanChildrenRoutes(routes, isChild = false, routeNameSplitter = "-", trailingSlash, parentRouteName = "") {
  const regExpIndex = new RegExp(`${routeNameSplitter}index$`);
  const regExpParentRouteName = new RegExp(`^${parentRouteName}${routeNameSplitter}`);
  const routesIndex = [];
  routes.forEach((route) => {
    if (regExpIndex.test(route.name) || route.name === "index") {
      const res = route.name.replace(regExpParentRouteName, "").split(routeNameSplitter);
      routesIndex.push(res);
    }
  });
  routes.forEach((route) => {
    route.path = isChild ? route.path.replace("/", "") : route.path;
    if (route.path.includes("?")) {
      if (route.name.endsWith(`${routeNameSplitter}index`))
        route.path = route.path.replace(/\?\/?$/, "");
      const names = route.name.replace(regExpParentRouteName, "").split(routeNameSplitter);
      const paths = route.path.split("/");
      if (!isChild)
        paths.shift();
      routesIndex.forEach((r) => {
        const i = r.indexOf("index");
        if (i < paths.length) {
          for (let a = 0; a <= i; a++) {
            if (a === i)
              paths[a] = paths[a].replace("?", "");
            if (a < i && names[a] !== r[a])
              break;
          }
        }
      });
      route.path = (isChild ? "" : "/") + paths.join("/");
    }
    route.name = route.name.replace(regExpIndex, "");
    if (route.children) {
      const defaultChildRoute = route.children.find((child) => child.path === "/" || child.path === "");
      const routeName = route.name;
      if (defaultChildRoute) {
        route.children.forEach((child) => {
          if (child.path !== defaultChildRoute.path) {
            const parts = child.path.split("/");
            parts[1] = parts[1].endsWith("?") ? parts[1].substr(0, parts[1].length - 1) : parts[1];
            child.path = parts.join("/");
          }
        });
        delete route.name;
      }
      route.children = cleanChildrenRoutes(route.children, true, routeNameSplitter, trailingSlash, routeName);
    }
  });
  return routes;
}

async function discoverRouteDefinitions() {
  const { resolvedConfig } = useUnlighthouse();
  if (!resolvedConfig.discovery)
    return [];
  const logger = useLogger();
  const { supportedExtensions, pagesDir } = resolvedConfig.discovery;
  const dir = pagesDir === "" ? resolvedConfig.root.replace(`${resolvedConfig.root}/`, "") : pagesDir;
  const resolveFiles = async (dir2) => {
    const { globby } = await import('globby');
    const extensions = supportedExtensions.length > 1 ? `{${supportedExtensions.join(",")}}` : supportedExtensions[0];
    return await globby([
      join(dir2, "**", `*.${extensions}`),
      "!**/README.md",
      "!**/node_modules"
    ], {
      cwd: resolvedConfig.root,
      // avoid some edge-cases
      deep: 5,
      // avoid scanning node_modules and any other expensive dirs
      gitignore: true
    });
  };
  const files = {};
  const ext = new RegExp(`\\.(${supportedExtensions.join("|")})$`);
  const resolvedPages = await resolveFiles(dir);
  for (const page of resolvedPages) {
    const key = page.replace(ext, "");
    if (/\.vue$/.test(page) || !files[key])
      files[key] = page.replace(/(['"])/g, "\\$1");
  }
  logger.debug(`Discovered \`${resolvedPages.length}\` page files from  \`${join(resolvedConfig.root, dir)}\`. Mapping to route definitions.`);
  if (resolvedPages.length)
    logger.debug(resolvedPages);
  return createRoutes({
    files: Object.values(files),
    srcDir: resolvedConfig.root,
    pagesDir: dir,
    routeNameSplitter: "-",
    supportedExtensions,
    trailingSlash: false
  }).map((route) => {
    const pathNodes = route.path.split("/");
    route.path = pathNodes.map((n) => {
      if (n.startsWith("[") && n.endsWith("]")) {
        const strippedNode = n.replace("[", "").replace("]", "").replace("...", "");
        return `:${strippedNode}`;
      }
      return n;
    }).join("/");
    return route;
  });
}

async function createApi(h3) {
  const logger = useLogger();
  const { ws, resolvedConfig, runtimeSettings, hooks } = useUnlighthouse();
  const useReport = () => {
    const { worker } = useUnlighthouse();
    const { id } = useParams();
    return worker.findReport(id);
  };
  const { app, setup } = await createUnrouted({
    name: "unlighthouse-api",
    debug: resolvedConfig.debug,
    prefix: resolvedConfig.routerPrefix,
    app: h3,
    hooks: {
      // @ts-expect-error untyped
      "serve:before-route": () => {
        return hooks.callHook("visited-client");
      }
    },
    presets: [
      presetApi(),
      presetNode({
        generateTypes: false
      })
    ]
  });
  await setup(() => {
    redirect("/__lighthouse/", resolvedConfig.routerPrefix);
    prefix("/api", () => {
      prefix("/reports", () => {
        post("/rescan", () => {
          const { worker } = useUnlighthouse();
          const reports = [...worker.routeReports.values()];
          logger.info(`Doing site rescan, clearing ${reports.length} reports.`);
          worker.routeReports.clear();
          reports.forEach((route) => {
            const dir = route.artifactPath;
            if (fs.existsSync(dir))
              fs.rmSync(dir, { recursive: true });
          });
          worker.queueRoutes(reports.map((report) => report.route));
          return true;
        });
        post("/:id/rescan", () => {
          const report = useReport();
          const { worker } = useUnlighthouse();
          if (report)
            worker.requeueReport(report);
        });
      });
      get("__launch", () => {
        const { file } = useQuery();
        if (!file) {
          setStatusCode(400);
          return false;
        }
        const path = file.replace(resolvedConfig.root, "");
        const resolved = join(resolvedConfig.root, path);
        logger.info(`Launching file in editor: \`${path}\``);
        launch(resolved);
      });
      get("ws", (event) => ws.serve(event.req));
      get("reports", () => {
        const { worker } = useUnlighthouse();
        return worker.reports().filter((r) => r.tasks.inspectHtmlTask === "completed");
      });
      get("scan-meta", () => createScanMeta());
    });
    serve("/", runtimeSettings.generatedClientPath);
  });
  return app;
}

function createBroadcastingEvents() {
  const { hooks, ws } = useUnlighthouse();
  if (!ws)
    return;
  hooks.hook("task-started", (path, response) => {
    if (response.tasks.inspectHtmlTask === "completed")
      ws.broadcast({ response });
  });
  hooks.hook("task-complete", (path, response) => {
    if (response.tasks.inspectHtmlTask === "completed")
      ws.broadcast({ response });
  });
  hooks.hook("task-added", (path, response) => {
    if (response.tasks.inspectHtmlTask === "completed")
      ws.broadcast({ response });
  });
}
class WS {
  wss;
  constructor() {
    this.wss = new WebSocketServer({ noServer: true });
  }
  serve(req) {
    this.handleUpgrade(req, req.socket);
  }
  handleUpgrade(request, socket) {
    return this.wss.handleUpgrade(request, socket, Buffer.alloc(0), (client) => {
      this.wss.emit("connection", client, request);
    });
  }
  /**
   * Publish event and data to all connected clients
   * @param {object} data
   */
  broadcast(data) {
    const jsonData = JSON.stringify(data);
    for (const client of this.wss.clients) {
      try {
        client.send(jsonData);
      } catch {
      }
    }
  }
}

const createMockRouter = (routeDefinitions) => {
  const logger = useLogger();
  const patterns = routeDefinitions.map((r) => {
    try {
      return {
        routeDefinition: r,
        matcher: parse(r.path)
      };
    } catch (e) {
      logger.debug("Failed to parse path", r.path, e);
    }
    return false;
  }).filter((r) => r !== false);
  return {
    match(path) {
      const matched = patterns.filter((p) => p && p.matcher.pattern.test(path));
      if (matched.length > 0 && matched[0])
        return matched[0].routeDefinition;
      return false;
    }
  };
};

function isScanOrigin(url) {
  if (isRelative(url) || url.startsWith("/") && !url.startsWith("//"))
    return true;
  const { runtimeSettings } = useUnlighthouse();
  const $url = new URL(url);
  if ($url.hostname === runtimeSettings.siteUrl.hostname)
    return true;
  return $url.hostname.endsWith(`.${runtimeSettings.siteUrl.hostname}`);
}
function normaliseRoute(url) {
  const { runtimeSettings, provider, resolvedConfig } = useUnlighthouse();
  if (!hasProtocol(url)) {
    url = withBase(url, runtimeSettings.siteUrl.origin);
  }
  const $url = new URL(url);
  const hash = $url.hash.startsWith("#/") ? $url.hash : "";
  const path = `${withLeadingSlash($url.pathname)}${hash}${$url.search}`;
  let normalised = {
    id: hashPathName(path),
    url,
    $url,
    path
  };
  for (const matcher in resolvedConfig.scanner.customSampling) {
    if (!new RegExp(matcher).test(path))
      continue;
    const definition = resolvedConfig.scanner.customSampling[matcher];
    normalised = {
      ...normalised,
      definition: {
        ...definition,
        path,
        componentBaseName: basename(definition.component || "")
      }
    };
    break;
  }
  if (!normalised.definition && provider.mockRouter && typeof provider.mockRouter !== "function") {
    const definition = provider.mockRouter.match(path);
    if (definition) {
      if (definition.file && !definition.component)
        definition.component = definition.file;
      normalised = {
        ...normalised,
        definition: {
          ...definition,
          componentBaseName: basename(definition.component || "")
        }
      };
    }
  }
  if (!normalised.definition) {
    const parts = trimSlashes(path).split("/");
    let name;
    if (path === "/") {
      name = "index";
    } else if (parts.length > 1) {
      name = parts.map((val, i) => {
        if (i >= parts.length - 1)
          return "slug";
        return val;
      }).join("-");
    } else {
      name = trimSlashes(path);
    }
    normalised = {
      ...normalised,
      definition: {
        name,
        path
      }
    };
  }
  if (normalised?.definition?.name === "index")
    normalised.definition.name = "_index";
  return normalised;
}

function parseRobotsTxt(s) {
  const groups = [];
  const sitemaps = [];
  let createNewGroup = false;
  let currentGroup = {
    comment: [],
    // comments are too hard to parse in a logical order, we'll just omit them
    disallow: [],
    allow: [],
    userAgent: []
  };
  for (const line of s.split("\n")) {
    const sepIndex = line.indexOf(":");
    if (sepIndex === -1)
      continue;
    const rule = line.substring(0, sepIndex).trim();
    const val = line.substring(sepIndex + 1).trim();
    switch (rule) {
      case "User-agent":
        if (createNewGroup) {
          groups.push({
            ...currentGroup
          });
          currentGroup = {
            comment: [],
            disallow: [],
            allow: [],
            userAgent: []
          };
          createNewGroup = false;
        }
        currentGroup.userAgent.push(val);
        break;
      case "Allow":
        currentGroup.allow.push(val);
        createNewGroup = true;
        break;
      case "Disallow":
        currentGroup.disallow.push(val);
        createNewGroup = true;
        break;
      case "Sitemap":
        sitemaps.push(val);
        break;
      case "Host":
        currentGroup.host = val;
        break;
    }
  }
  groups.push({
    ...currentGroup
  });
  return {
    groups: groups.map(normalizeGroup),
    sitemaps
  };
}
function asArray(v) {
  return typeof v === "undefined" ? [] : Array.isArray(v) ? v : [v];
}
function normalizeGroup(group) {
  const disallow = asArray(group.disallow);
  const allow = asArray(group.allow).filter((rule) => Boolean(rule));
  return {
    ...group,
    userAgent: group.userAgent ? asArray(group.userAgent) : ["*"],
    disallow,
    allow,
    _indexable: !disallow.includes((rule) => rule === "/"),
    _rules: [
      ...disallow.filter(Boolean).map((r) => ({ pattern: r, allow: false })),
      ...allow.map((r) => ({ pattern: r, allow: true }))
    ]
  };
}

function validSitemapEntry(url) {
  return url && (url.startsWith("http") || url.startsWith("/"));
}
async function extractSitemapRoutes(site, sitemaps) {
  site = new $URL(site).origin;
  const unlighthouse = useUnlighthouse();
  const logger = useLogger();
  if (sitemaps === true || sitemaps.length === 0)
    sitemaps = [`${site}/sitemap.xml`];
  const sitemap = new Sitemapper({
    timeout: 15e3,
    // 15 seconds
    debug: unlighthouse.resolvedConfig.debug
  });
  let paths = [];
  for (let sitemapUrl of new Set(sitemaps)) {
    logger.debug(`Attempting to fetch sitemap at ${sitemapUrl}`);
    if (!sitemapUrl.startsWith("http"))
      sitemapUrl = withBase(sitemapUrl, site);
    if (sitemapUrl.endsWith(".txt")) {
      const sitemapTxt = await fetchUrlRaw(
        sitemapUrl,
        unlighthouse.resolvedConfig
      );
      if (sitemapTxt.valid) {
        const sites = sitemapTxt.response.data.trim().split("\n").filter(validSitemapEntry);
        if (sites?.length)
          paths = [...paths, ...sites];
        logger.debug(`Fetched ${sitemapUrl} with ${sites.length} URLs.`);
      }
    } else {
      const { sites } = await sitemap.fetch(sitemapUrl);
      if (sites?.length)
        paths = [...paths, ...sites];
      logger.debug(`Fetched ${sitemapUrl} with ${sites?.length || "0"} URLs.`);
    }
  }
  const filtered = paths.filter(isScanOrigin);
  return { paths: filtered, ignored: paths.length - filtered.length, sitemaps };
}

let warnedAboutSampling = false;
const resolveReportableRoutes = async () => {
  const logger = useLogger();
  const { resolvedConfig, hooks, worker, routeDefinitions } = useUnlighthouse();
  const urls = /* @__PURE__ */ new Set([]);
  if (resolvedConfig.urls?.length) {
    let urlsToAdd;
    if (typeof resolvedConfig.urls === "function")
      urlsToAdd = [...await resolvedConfig.urls()];
    else
      urlsToAdd = [...resolvedConfig.urls];
    urlsToAdd.forEach((url) => urls.add(url));
    if (urlsToAdd.length) {
      resolvedConfig.scanner.sitemap = false;
      resolvedConfig.scanner.robotsTxt = false;
      resolvedConfig.scanner.crawler = false;
      resolvedConfig.scanner.dynamicSampling = false;
      logger.info(`The \`url\` config has been provided with ${urlsToAdd.length} paths for scanning. Disabling sitemap, robots, sampling and crawler.`);
    }
  } else {
    urls.add(resolvedConfig.site);
  }
  if (resolvedConfig.scanner.robotsTxt) {
    const robotsTxt = await fetchRobotsTxt(resolvedConfig.site);
    if (robotsTxt) {
      const robotsTxtParsed = parseRobotsTxt(robotsTxt);
      logger.info(`Found /robots.txt, using entries. Sitemaps: ${robotsTxtParsed.sitemaps.length}, Groups: ${robotsTxtParsed.groups.length}.`);
      mergeRobotsTxtConfig(resolvedConfig, robotsTxtParsed);
    }
  }
  if (resolvedConfig.scanner.sitemap !== false) {
    const { paths: sitemapUrls, ignored, sitemaps } = await extractSitemapRoutes(resolvedConfig.site, resolvedConfig.scanner.sitemap);
    if (ignored > 0 && !sitemapUrls.length) {
      logger.warn(`Sitemap${sitemaps.length > 1 ? "s" : ""} exists but is being ignored due to a different origin being present`);
    } else if (sitemapUrls.length) {
      logger.info(`Discovered ${sitemapUrls.length} routes from ${sitemaps.length} sitemap${sitemaps.length > 1 ? "s" : ""}.`);
      if (ignored > 0)
        logger.warn(`Ignoring ${ignored} paths from sitemap as their origin differs from the site url.`);
      sitemapUrls.forEach((url) => urls.add(url));
      if (!resolvedConfig.site.includes("localhost") && sitemapUrls.length >= 50) {
        resolvedConfig.scanner.crawler = false;
        logger.info("Disabling crawler mode as sitemap has been provided.");
      }
    } else if (resolvedConfig.scanner.crawler) {
      resolvedConfig.scanner.sitemap = false;
      logger.info("Sitemap appears to be missing, falling back to crawler mode.");
    } else {
      resolvedConfig.scanner.sitemap = false;
      logger.error("Failed to find sitemap.xml and `routes.crawler` has been disabled. Please enable the crawler to continue scan.");
    }
  }
  if (urls.size <= 1 && routeDefinitions?.length) {
    routeDefinitions.filter((r) => !r.path.includes(":")).map((r) => r.path).forEach((url) => urls.add(url));
  }
  if (resolvedConfig.scanner.crawler) {
    hooks.hook("discovered-internal-links", (path, internalLinks) => {
      if (path === "/" && internalLinks.length <= 0 && resolvedConfig.scanner.skipJavascript) {
        resolvedConfig.scanner.skipJavascript = false;
        resolvedConfig.cache = false;
        worker.routeReports.clear();
        worker.queueRoute(normaliseRoute(path));
        logger.warn("No internal links discovered on home page. Switching crawler to execute javascript and disabling cache.");
        return;
      }
      worker.queueRoutes(internalLinks.map((url) => normaliseRoute(url)).map((route) => {
        route.discoveredFrom = path;
        return route;
      }));
    });
  }
  const validUrls = [...urls.values()].filter((url) => isScanOrigin(url));
  if (!resolvedConfig.scanner.dynamicSampling)
    return validUrls.map((url) => normaliseRoute(url));
  const pathsChunkedToGroup = groupBy(
    validUrls.map((url) => normaliseRoute(url)),
    resolvedConfig.client.groupRoutesKey.replace("route.", "")
  );
  const pathsSampleChunkedToGroup = map(
    pathsChunkedToGroup,
    // we're matching dynamic rates here, only taking a sample to avoid duplicate tests
    (group) => {
      const { dynamicSampling } = resolvedConfig.scanner;
      if (!dynamicSampling)
        return group;
      if (!warnedAboutSampling && group.length > dynamicSampling) {
        logger.warn("Dynamic sampling is in effect, some of your routes will not be scanned. To disable this behavior, set `scanner.dynamicSampling` to `false`.");
        warnedAboutSampling = true;
      }
      return sampleSize(group, dynamicSampling);
    }
  );
  return pathsSampleChunkedToGroup.flat();
};

async function launchPuppeteerCluster() {
  const { resolvedConfig } = useUnlighthouse();
  const cluster = await Cluster.launch({
    puppeteerOptions: resolvedConfig.puppeteerOptions,
    ...resolvedConfig.puppeteerClusterOptions
  });
  cluster.display = {
    log() {
    },
    resetCursor() {
    }
  };
  return cluster;
}

function createFilter(options = {}) {
  const include = options.include || [];
  const exclude = options.exclude || [];
  if (include.length === 0 && exclude.length === 0)
    return () => true;
  return function(path) {
    for (const v of [{ rules: include, result: true }, { rules: exclude, result: false }]) {
      const regexRules = v.rules.filter((r) => r instanceof RegExp);
      if (regexRules.some((r) => r.test(path)))
        return v.result;
      const stringRules = v.rules.filter((r) => typeof r === "string");
      if (stringRules.length > 0) {
        const routes = {};
        for (const r of stringRules) {
          if (r === path)
            return v.result;
          routes[r] = true;
        }
        const routeRulesMatcher = toRouteMatcher(createRouter({ routes, strictTrailingSlash: false }));
        if (routeRulesMatcher.matchAll(path).length > 0)
          return Boolean(v.result);
      }
    }
    return include.length === 0;
  };
}
const HTML_EXPLICIT_EXTENSIONS = [
  // html
  ".html",
  ".htm",
  // php
  ".php",
  // asp
  ".asp",
  ".aspx"
];
const FILE_MATCH_REGEX = /\.([0-9a-z])+$/i;
function isImplicitOrExplicitHtml(path) {
  const lastPathSegment = path.split("/").pop() || path;
  if (lastPathSegment.endsWith("/"))
    return true;
  const extension = lastPathSegment?.match(FILE_MATCH_REGEX)?.[0];
  return !extension || HTML_EXPLICIT_EXTENSIONS.includes(extension);
}

async function setupPage(page) {
  const { resolvedConfig, hooks } = useUnlighthouse();
  const logger = useLogger();
  const softErrorHandler = (ctx) => (err) => {
    logger.error(ctx, err);
  };
  const browser = page.browser();
  await page.setBypassCSP(true);
  if (resolvedConfig.auth)
    await page.authenticate(resolvedConfig.auth).catch(softErrorHandler("Failed to authenticate"));
  if (resolvedConfig.localStorage) {
    await page.evaluateOnNewDocument(
      (data) => {
        localStorage.clear();
        for (const key in data)
          localStorage.setItem(key, data[key]);
      },
      resolvedConfig.localStorage
    );
  }
  if (resolvedConfig.sessionStorage) {
    await page.evaluateOnNewDocument(
      (data) => {
        sessionStorage.clear();
        for (const key in data)
          sessionStorage.setItem(key, data[key]);
      },
      resolvedConfig.sessionStorage
    );
  }
  if (resolvedConfig.cookies) {
    await page.setCookie(...resolvedConfig.cookies.map((cookie) => ({ domain: resolvedConfig.site, ...cookie }))).catch(softErrorHandler("Failed to set cookies"));
  }
  if (resolvedConfig.extraHeaders) {
    await page.setExtraHTTPHeaders(resolvedConfig.extraHeaders).catch(softErrorHandler("Failed to set extra headers"));
  }
  browser.on("targetchanged", async (target) => {
    const page2 = await target.page();
    if (page2) {
      if (resolvedConfig.cookies) {
        await page2.setCookie(...resolvedConfig.cookies.map((cookie) => ({ domain: resolvedConfig.site, ...cookie }))).catch(softErrorHandler("Failed to set cookies"));
      }
      if (resolvedConfig.extraHeaders) {
        await page2.setExtraHTTPHeaders(resolvedConfig.extraHeaders).catch(softErrorHandler("Failed to set extra headers"));
      }
      if (resolvedConfig.userAgent) {
        await page2.setUserAgent(resolvedConfig.userAgent);
      }
      await hooks.callHook("puppeteer:before-goto", page2);
    }
  });
}

const extractHtmlPayload = async (page, route) => {
  const { worker, resolvedConfig } = useUnlighthouse();
  if (resolvedConfig.scanner.skipJavascript) {
    const { valid, response, redirected, redirectUrl } = await fetchUrlRaw(route, resolvedConfig);
    if (!valid || !response)
      return { success: false, message: `Invalid response from URL ${route} code: ${response?.status || "404"}.` };
    if (response.headers["content-type"] && !response.headers["content-type"].includes("text/html"))
      return { success: false, message: `Non-HTML Content-Type header: ${response.headers["content-type"]}.` };
    return {
      success: true,
      redirected: redirected ? redirectUrl : false,
      payload: response.data
    };
  }
  try {
    await page.setCacheEnabled(false);
    await page.setRequestInterception(true);
    page.on("request", (request) => {
      if (["image", "stylesheet", "font", "other"].includes(request.resourceType()))
        request.abort();
      else
        request.continue();
    });
    await setupPage(page);
    const pageVisit = await page.goto(route, { waitUntil: resolvedConfig.scanner.skipJavascript ? "domcontentloaded" : "networkidle2" });
    if (!pageVisit)
      return { success: false, message: `Failed to go to route ${route}.` };
    const { "content-type": contentType, location } = pageVisit.headers();
    const statusCode = pageVisit.status();
    if ((statusCode === 301 || statusCode === 302) && location) {
      worker.queueRoute(normaliseRoute(location));
      return { success: false, message: `Redirect, queued the new URL: ${location}.` };
    }
    if (statusCode < 200 || statusCode >= 300)
      return { success: false, message: `Invalid status code: ${statusCode}.` };
    if (contentType && !contentType.includes("text/html"))
      return { success: false, message: `Invalid content-type header: ${contentType}.` };
    const payload = await (resolvedConfig.scanner.skipJavascript ? pageVisit.text() : page.evaluate(() => document.querySelector("*")?.outerHTML));
    return {
      success: true,
      payload
    };
  } catch (e) {
    return { success: false, message: `Exception thrown when visiting route: ${e}.` };
  }
};
function processSeoMeta($) {
  return {
    alternativeLangDefault: $('link[hreflang="x-default"]').attr("href"),
    favicon: $('link[rel~="icon"]').attr("href") || "/favicon.ico",
    title: $("meta[name='title'], head > title").text(),
    description: $("meta[name='description']").attr("content"),
    og: {
      image: $("meta[property='og:image'], meta[name='og:image']").attr("content"),
      description: $("meta[property='og:description'], meta[name='og:description']").attr("content"),
      title: $("meta[property='og:title'], meta[name='og:title']").attr("content")
    }
  };
}
const inspectHtmlTask = async (props) => {
  const unlighthouse = useUnlighthouse();
  const { resolvedConfig, hooks, runtimeSettings } = unlighthouse;
  const { page, data: routeReport } = props;
  const logger = useLogger();
  let html;
  const htmlPayloadPath = join(routeReport.artifactPath, ReportArtifacts.html);
  if (resolvedConfig.cache && fs.existsSync(htmlPayloadPath)) {
    html = fs.readFileSync(htmlPayloadPath, { encoding: "utf-8" });
    logger.debug(`Running \`inspectHtmlTask\` for \`${routeReport.route.path}\` using cache.`);
  } else {
    const response = await extractHtmlPayload(page, routeReport.route.url);
    logger.debug(`HTML extract of \`${routeReport.route.url}\` response ${response.success ? "succeeded" : "failed"}.`);
    if (!response.success || !response.payload) {
      routeReport.tasks.inspectHtmlTask = "ignore";
      logger.info(`Skipping ${routeReport.route.path}. ${response.message}`);
      return routeReport;
    }
    if (response.redirected) {
      const siteHost = runtimeSettings.siteUrl.host.split(":")[0];
      const redirectHost = new URL(response.redirected).host.split(":")[0];
      if (siteHost !== redirectHost && !redirectHost.endsWith(`.${siteHost}`)) {
        routeReport.tasks.inspectHtmlTask = "ignore";
        logger.warn(`Redirected URL goes to a different domain, ignoring. \`${response.redirected}.`);
        return routeReport;
      }
      if (withoutTrailingSlash(response.redirected) !== withoutTrailingSlash(runtimeSettings.siteUrl.href))
        logger.info("Redirected url detected, this may cause issues in the final report.", response.redirected);
    }
    html = response.payload;
  }
  const $ = load(html);
  routeReport.seo = processSeoMeta($);
  if (resolvedConfig.scanner.ignoreI18nPages && routeReport.seo.alternativeLangDefault && withoutTrailingSlash(routeReport.route.url) !== withoutTrailingSlash(routeReport.seo.alternativeLangDefault)) {
    routeReport.tasks.inspectHtmlTask = "ignore";
    if (!unlighthouse._i18nWarn) {
      unlighthouse._i18nWarn = true;
      logger.warn(`Page has an alternative lang, ignoring \`${routeReport.route.path}\`: ${routeReport.seo.alternativeLangDefault}. You can disable this behavior with the \`scanner.ignoreI18nPages = true\` option. Future warnings will be suppressed.`);
    } else {
      logger.debug(`Page has an alternative lang, ignoring \`${routeReport.route.path}\`: ${routeReport.seo.alternativeLangDefault}`);
    }
    unlighthouse.worker.queueRoute(normaliseRoute(routeReport.seo.alternativeLangDefault));
    return routeReport;
  }
  const internalLinks = [];
  const externalLinks = [];
  $("a").each(function() {
    const href = $(this).attr("href");
    if (!href || href.includes("javascript:") || href.includes("mailto:") || href === "#" || !isImplicitOrExplicitHtml(href))
      return;
    if (href.startsWith("/") && !href.startsWith("//") || href.includes(resolvedConfig.site))
      internalLinks.push(href);
    else
      externalLinks.push(href);
  });
  await hooks.callHook("discovered-internal-links", routeReport.route.path, internalLinks);
  routeReport.seo.internalLinks = internalLinks.length;
  routeReport.seo.externalLinks = externalLinks.length;
  routeReport.seo.htmlSize = html.length;
  if (resolvedConfig.cache)
    fs.writeFileSync(htmlPayloadPath, html);
  return routeReport;
};

function normaliseLighthouseResult(route, result) {
  const { resolvedConfig, runtimeSettings } = useUnlighthouse();
  const measuredCategories = Object.values(result.categories).filter((c) => typeof c.score !== "undefined");
  const columnFields = Object.values(resolvedConfig.client.columns).flat().filter((c) => !!c.key).map((c) => c.key?.replace("report.", ""));
  const imageIssues = [
    result.audits["unsized-images"],
    result.audits["preload-lcp-image"],
    result.audits["offscreen-images"],
    result.audits["modern-image-formats"],
    result.audits["uses-optimized-images"],
    result.audits["efficient-animated-content"],
    result.audits["uses-responsive-images"]
  ].map((d) => d?.details?.items || []).flat();
  const ariaIssues = Object.values(result.audits).filter((a) => a && a.id.startsWith("aria-") && a.details?.items?.length > 0).map((a) => a.details?.items).flat();
  if (result.audits["screenshot-thumbnails"]?.details?.items) {
    for (const k in result.audits["screenshot-thumbnails"].details.items)
      result.audits["screenshot-thumbnails"].details.items[k].data = relative(runtimeSettings.generatedClientPath, join(route.artifactPath, ReportArtifacts.screenshotThumbnailsDir, `${k}.jpeg`));
  }
  return {
    // @ts-expect-error type override
    categories: map(result.categories, (c, k) => {
      return {
        key: k,
        id: k,
        ...pick(c, ["title", "score"])
      };
    }),
    ...pick(result, [
      "fetchTime",
      "audits.redirects",
      // core web vitals
      "audits.layout-shifts",
      "audits.largest-contentful-paint-element",
      "audits.largest-contentful-paint",
      "audits.cumulative-layout-shift",
      "audits.first-contentful-paint",
      "audits.total-blocking-time",
      "audits.max-potential-fid",
      "audits.interactive",
      ...columnFields
    ]),
    computed: {
      imageIssues: {
        details: {
          items: imageIssues
        },
        displayValue: imageIssues.length,
        score: imageIssues.length > 0 ? 0 : 1
      },
      ariaIssues: {
        details: {
          items: ariaIssues
        },
        displayValue: ariaIssues.length,
        score: ariaIssues.length > 0 ? 0 : 1
      }
    },
    score: Math.round(sumBy(measuredCategories, "score") / measuredCategories.length * 100) / 100
  };
}
const runLighthouseTask = async (props) => {
  const logger = useLogger();
  const { resolvedConfig, runtimeSettings } = useUnlighthouse();
  const { page, data: routeReport } = props;
  const reportJsonPath = join(routeReport.artifactPath, ReportArtifacts.reportJson);
  if (resolvedConfig.cache && fs.existsSync(reportJsonPath)) {
    try {
      const report2 = fs.readJsonSync(reportJsonPath, { encoding: "utf-8" });
      routeReport.report = normaliseLighthouseResult(routeReport, report2);
      return routeReport;
    } catch (e) {
      logger.warn(`Failed to read cached lighthouse report for path "${routeReport.route.path}".`, e);
    }
  }
  await setupPage(page);
  const port = new URL(page.browser().wsEndpoint()).port;
  const clonedRouteReport = { ...routeReport };
  if (resolvedConfig.defaultQueryParams)
    clonedRouteReport.route.url = withQuery(clonedRouteReport.route.url, resolvedConfig.defaultQueryParams);
  const args = [
    `--cache=${JSON.stringify(resolvedConfig.cache)}`,
    `--routeReport=${JSON.stringify(pick(clonedRouteReport, ["route.url", "artifactPath"]))}`,
    `--lighthouseOptions=${JSON.stringify(resolvedConfig.lighthouseOptions)}`,
    `--port=${port}`
  ];
  const samples = [];
  for (let i = 0; i < resolvedConfig.scanner.samples; i++) {
    try {
      const worker = (await import('execa')).execa(
        // handles stubbing
        runtimeSettings.lighthouseProcessPath.endsWith(".ts") ? "jiti" : "node",
        [runtimeSettings.lighthouseProcessPath, ...args],
        {
          timeout: 6 * 60 * 1e3
        }
      );
      worker.stdout.pipe(process.stdout);
      worker.stderr.pipe(process.stderr);
      const res = await worker;
      if (res)
        samples.push(fs.readJsonSync(reportJsonPath));
    } catch (e) {
      logger.error("Failed to run lighthouse for route", e);
      return routeReport;
    }
  }
  let report = samples[0];
  if (!report) {
    logger.error(`Task \`runLighthouseTask\` has failed to run for path "${routeReport.route.path}".`);
    routeReport.tasks.runLighthouseTask = "failed";
    return routeReport;
  }
  if (report.categories.performance && !report.categories.performance.score) {
    logger.warn(`Lighthouse failed to run performance audits for "${routeReport.route.path}", adding back to queue${report.runtimeError ? `: ${report.runtimeError.message}` : "."}`);
    routeReport.tasks.runLighthouseTask = "failed-retry";
    return routeReport;
  }
  if (samples.length > 1) {
    try {
      report = computeMedianRun(samples);
    } catch (e) {
      logger.warn("Error when computing median score, possibly audit failed.", e);
    }
  }
  if (report.audits?.["final-screenshot"]?.details?.data)
    await fs.writeFile(join(routeReport.artifactPath, ReportArtifacts.screenshot), base64ToBuffer(report.audits["final-screenshot"].details.data));
  if (report.fullPageScreenshot?.screenshot.data)
    await fs.writeFile(join(routeReport.artifactPath, ReportArtifacts.fullScreenScreenshot), base64ToBuffer(report.fullPageScreenshot.screenshot.data));
  const screenshotThumbnails = report.audits?.["screenshot-thumbnails"]?.details;
  await fs.mkdir(join(routeReport.artifactPath, ReportArtifacts.screenshotThumbnailsDir), { recursive: true });
  if (screenshotThumbnails?.items && screenshotThumbnails.type === "filmstrip") {
    for (const key in screenshotThumbnails.items) {
      const thumbnail = screenshotThumbnails.items[key];
      await fs.writeFile(join(routeReport.artifactPath, ReportArtifacts.screenshotThumbnailsDir, `${key}.jpeg`), base64ToBuffer(thumbnail.data));
    }
  }
  routeReport.report = normaliseLighthouseResult(routeReport, report);
  return routeReport;
};

let warnedMaxRoutesExceeded = false;
async function createUnlighthouseWorker(tasks) {
  const { hooks, resolvedConfig } = useUnlighthouse();
  const logger = useLogger();
  const cluster = await launchPuppeteerCluster();
  const routeReports = /* @__PURE__ */ new Map();
  const ignoredRoutes = /* @__PURE__ */ new Set();
  const retriedRoutes = /* @__PURE__ */ new Map();
  const monitor = () => {
    const now = Date.now();
    const timeDiff = now - cluster.startTime;
    const doneTargets = cluster.allTargetCount - cluster.jobQueue.size() - cluster.workersBusy.length;
    const donePercentage = cluster.allTargetCount === 0 ? 1 : doneTargets / cluster.allTargetCount;
    const donePercStr = (100 * donePercentage).toFixed(0);
    const errorPerc = doneTargets === 0 ? "0.00" : (100 * cluster.errorCount / doneTargets).toFixed(2);
    const timeRunning = timeDiff;
    let timeRemainingMillis = -1;
    if (donePercentage !== 0)
      timeRemainingMillis = Math.round(timeDiff / donePercentage - timeDiff);
    const timeRemaining = timeRemainingMillis;
    const cpuUsage = `${cluster.systemMonitor.getCpuUsage().toFixed(1)}%`;
    const memoryUsage = `${cluster.systemMonitor.getMemoryUsage().toFixed(1)}%`;
    const pagesPerSecond = doneTargets === 0 ? "0" : (doneTargets * 1e3 / timeDiff).toFixed(2);
    return {
      status: cluster.allTargetCount === doneTargets ? "completed" : "working",
      timeRunning,
      doneTargets,
      allTargets: cluster.allTargetCount,
      donePercStr,
      errorPerc,
      timeRemaining,
      pagesPerSecond,
      cpuUsage,
      memoryUsage,
      workers: cluster.workers.length + cluster.workersStarting
    };
  };
  const exceededMaxRoutes = () => {
    return resolvedConfig.scanner.maxRoutes !== false && routeReports.size >= resolvedConfig.scanner.maxRoutes;
  };
  const queueRoute = (route) => {
    const { id, path } = route;
    if (exceededMaxRoutes()) {
      if (!warnedMaxRoutesExceeded) {
        logger.warn(`You have reached the \`scanner.maxRoutes\` limit of ${resolvedConfig.scanner.maxRoutes}. No further routes will be queued, consider raising this limit.`);
        warnedMaxRoutesExceeded = true;
        return;
      }
      return;
    }
    if (routeReports.has(id))
      return;
    if (ignoredRoutes.has(id))
      return;
    if (resolvedConfig.scanner.robotsTxt && resolvedConfig.scanner._robotsTxtRules?.length) {
      const rule = matchPathToRule(path, resolvedConfig.scanner._robotsTxtRules);
      if (rule && !rule.allow) {
        logger.info(`Skipping route based on robots.txt rule \`${rule.pattern}\``, { path });
        return;
      }
    }
    if (resolvedConfig.scanner.include || resolvedConfig.scanner.exclude) {
      const filter = createFilter(resolvedConfig.scanner);
      if (!filter(path)) {
        logger.info("Skipping route based on include / exclude rules", {
          path,
          include: resolvedConfig.scanner.include,
          exclude: resolvedConfig.scanner.exclude
        });
        return;
      }
    }
    if (!isImplicitOrExplicitHtml(path)) {
      logger.debug("Skipping non-HTML file from scanning", { path });
      return;
    }
    if (resolvedConfig.scanner.dynamicSampling && resolvedConfig.scanner.dynamicSampling > 0) {
      const routeGroup = get$1(route, resolvedConfig.client.groupRoutesKey.replace("route.", ""));
      const routesInGroup = [...routeReports.values()].filter(
        (r) => get$1(r, resolvedConfig.client.groupRoutesKey) === routeGroup
      ).length;
      if (routesInGroup >= resolvedConfig.scanner.dynamicSampling) {
        return;
      }
    }
    const routeReport = createTaskReportFromRoute(route);
    logger.debug(`Route has been queued. Path: \`${path}\` Name: ${routeReport.route.definition?.name}.`);
    routeReports.set(id, routeReport);
    hooks.callHook("task-added", path, routeReport);
    const runTaskIndex = (idx = 0) => {
      const taskName = Object.keys(tasks)?.[idx];
      if (!taskName) {
        if (monitor().status === "completed")
          hooks.callHook("worker-finished");
        return;
      }
      const task = Object.values(tasks)[idx];
      routeReport.tasks[taskName] = "waiting";
      cluster.execute(routeReport, (arg) => {
        routeReport.tasks[taskName] = "in-progress";
        routeReport.tasksTime = routeReport.tasksTime || {};
        routeReport.tasksTime[taskName] = Date.now();
        hooks.callHook("task-started", path, routeReport);
        return task(arg);
      }).then((response) => {
        if (response.tasks[taskName] === "ignore") {
          routeReports.delete(id);
          ignoredRoutes.add(id);
          logger.debug(`Ignoring route \`${routeReport.route.path}\`.`);
          return;
        }
        if (response.tasks[taskName] === "failed")
          return;
        if (response.tasks[taskName] === "failed-retry") {
          const currentRetries = retriedRoutes.get(id) || 0;
          if (currentRetries < 3) {
            retriedRoutes.set(id, currentRetries + 1);
            requeueReport(routeReport);
          }
          return;
        }
        response.tasks[taskName] = "completed";
        routeReports.set(id, response);
        hooks.callHook("task-complete", path, response, taskName);
        const ms = Date.now() - routeReport.tasksTime?.[taskName];
        const seconds = (ms / 1e3).toFixed(1);
        const reportData = [
          `Time Taken: ${seconds}s`
        ];
        if (taskName === "runLighthouseTask") {
          if (response.report?.score)
            reportData.push(`Score: ${response.report.score}`);
          if (resolvedConfig.scanner.samples)
            reportData.push(`Samples: ${resolvedConfig.scanner.samples}`);
        } else if (taskName === "inspectHtmlTask") {
          if (response.seo.htmlSize)
            reportData.push(formatBytes(response.seo.htmlSize));
        }
        reportData.push(`${monitor().donePercStr}% complete`);
        logger.success(`Completed \`${taskName}\` for \`${routeReport.route.path}\`. ${colorize("gray", `(${reportData.join(" ")})`)}`);
        runTaskIndex(idx + 1);
      });
    };
    runTaskIndex();
  };
  const queueRoutes = (routes) => {
    routes = uniqBy(routes, "path");
    const sortedRoutes = sortBy(routes, (r) => {
      if (resolvedConfig.discovery && r.definition)
        return get$1(r, resolvedConfig.client.groupRoutesKey.replace("route.", ""));
      return r.path;
    });
    sortedRoutes.forEach((route) => queueRoute(route));
  };
  const requeueReport = (report) => {
    logger.info(`Submitting \`${report.route.path}\` for a re-queue.`);
    Object.values(ReportArtifacts).forEach((artifact) => {
      fs$1.rmSync(join(report.artifactPath, artifact), { force: true, recursive: true });
    });
    routeReports.delete(report.reportId);
    setTimeout(() => {
      queueRoute(report.route);
    }, 3500);
  };
  const hasStarted = () => cluster.workers.length || cluster.workersStarting;
  const reports = () => [...routeReports.values()];
  const invalidateFile = (file) => {
    if (file.startsWith(resolvedConfig.outputPath))
      return false;
    const matched = reports().filter((r) => r.route.definition.component === file || r.route.definition.component?.endsWith(file));
    if (matched.length) {
      logger.info(`Invalidating file ${file}, matched ${matched.length} routes.`);
      matched.forEach((r) => requeueReport(r));
      return true;
    }
    return false;
  };
  const findReport = (id) => reports().filter((report) => report.reportId === id)?.[0];
  return {
    cluster,
    routeReports,
    exceededMaxRoutes,
    requeueReport,
    invalidateFile,
    queueRoute,
    queueRoutes,
    findReport,
    monitor,
    hasStarted,
    reports
  };
}

const resolveUserConfig = async (userConfig) => {
  const logger = useLogger();
  const merger = createDefu((obj, key, value) => {
    if ((key === "supportedExtensions" || key === "onlyCategories") && value) {
      obj[key] = value;
      return true;
    }
  });
  const config = merger(userConfig, defaultConfig);
  if (!config.site && Array.isArray(config.urls) && config.urls?.[0])
    config.site = config.urls[0];
  if (config.site) {
    const siteUrl = normaliseHost(config.site);
    if (siteUrl.pathname !== "/" && siteUrl.pathname !== "") {
      logger.warn("You are providing a site with a path, disabling sitemap, robots and dynamic sampling.");
      config.scanner = config.scanner || {};
      config.scanner.sitemap = false;
      config.scanner.robotsTxt = false;
      config.scanner.dynamicSampling = false;
      config.site = siteUrl.toString();
    } else {
      config.site = siteUrl.origin;
    }
  }
  if (config.lighthouseOptions) {
    if (config.lighthouseOptions.onlyCategories?.length) {
      if (config.lighthouseOptions.onlyAudits?.length) {
        logger.warn("You have specified both `onlyCategories` and `onlyAudits`. `onlyCategories` will be ignored.");
        config.lighthouseOptions.onlyCategories = [];
      } else {
        config.lighthouseOptions.onlyCategories = defaultConfig.lighthouseOptions.onlyCategories.filter((column) => config.lighthouseOptions.onlyCategories.includes(column));
      }
    }
  } else {
    config.lighthouseOptions = {};
  }
  if (typeof config.lighthouseOptions.throttlingMethod === "undefined" && typeof config.lighthouseOptions.throttling === "undefined") {
    if (typeof config.scanner?.throttle) {
      config.lighthouseOptions.throttlingMethod = "simulate";
      config.lighthouseOptions.throttling = {
        rttMs: 150,
        throughputKbps: 1.6 * 1024,
        requestLatencyMs: 150 * 4,
        downloadThroughputKbps: 1.6 * 1024,
        uploadThroughputKbps: 750,
        cpuSlowdownMultiplier: 1
      };
    } else if (!config.site || config.site.includes("localhost") || config.scanner?.throttle === false) {
      config.lighthouseOptions.throttlingMethod = "provided";
      config.lighthouseOptions.throttling = {
        rttMs: 0,
        throughputKbps: 0,
        cpuSlowdownMultiplier: 1,
        requestLatencyMs: 0,
        // 0 means unset
        downloadThroughputKbps: 0,
        uploadThroughputKbps: 0
      };
    }
  }
  config.scanner.exclude = config.scanner?.exclude || [];
  config.scanner.exclude.push("/cdn-cgi/*");
  config.chrome = defu(config.chrome || {}, {
    useSystem: true,
    useDownloadFallback: true,
    downloadFallbackCacheDir: join(homedir(), ".unlighthouse")
  });
  if (config.auth) {
    config.lighthouseOptions.extraHeaders = config.lighthouseOptions.extraHeaders || {};
    if (!config.lighthouseOptions.extraHeaders.Authorization) {
      const credentials = `${config.auth.username}:${config.auth.password}`;
      config.lighthouseOptions.extraHeaders.Authorization = `Basic ${Buffer.from(credentials).toString("base64")}`;
    }
  }
  if (config.client?.columns) {
    config.client.columns = pick(config.client.columns, ["overview", ...config.lighthouseOptions.onlyCategories]);
  }
  if (config.root && config.discovery && config.discovery.pagesDir === "pages") {
    const pagesDirExist = await pathExists(join(config.root, config.discovery.pagesDir));
    if (!pagesDirExist) {
      logger.debug("Unable to locale page files, disabling route discovery.");
      config.discovery = false;
    }
  }
  config.lighthouseOptions.formFactor = config.lighthouseOptions.formFactor || config.scanner?.device || "mobile";
  if (config.lighthouseOptions.formFactor === "desktop") {
    config.lighthouseOptions.screenEmulation = {
      mobile: false,
      width: 1350,
      height: 940,
      deviceScaleFactor: 1,
      disabled: false
    };
  } else {
    config.lighthouseOptions.screenEmulation = {
      mobile: true,
      width: 412,
      height: 823,
      deviceScaleFactor: 1.75,
      disabled: false
    };
  }
  if (!config.lighthouseOptions.emulatedUserAgent) {
    if (config.lighthouseOptions.formFactor === "mobile")
      config.lighthouseOptions.emulatedUserAgent = "Mozilla/5.0 (Linux; Android 11; moto g power (2022)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Mobile Safari/537.36";
    else
      config.lighthouseOptions.emulatedUserAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36";
  }
  if (userConfig.extraHeaders)
    config.lighthouseOptions.extraHeaders = userConfig.extraHeaders;
  if (config.routerPrefix)
    config.routerPrefix = withSlashes(config.routerPrefix);
  config.puppeteerOptions = defu(config.puppeteerOptions, {
    // try avoid timeouts
    timeout: 0,
    protocolTimeout: 0
  });
  config.puppeteerClusterOptions = defu(config.puppeteerClusterOptions, {
    timeout: 12e4
  });
  config.puppeteerOptions = defu(config.puppeteerOptions, {
    // set viewport
    headless: true,
    ignoreHTTPSErrors: true
  });
  config.puppeteerOptions.defaultViewport = config.lighthouseOptions.screenEmulation;
  let foundChrome = !!config.puppeteerOptions?.executablePath;
  if (config.chrome.useSystem && !foundChrome) {
    let chromePath = false;
    try {
      chromePath = Launcher.getFirstInstallation();
    } catch (e) {
      logger.debug("Chrome launcher failed to get a path.", e);
    }
    if (chromePath) {
      logger.info(`Using system Chrome located at: \`${chromePath}\`.`);
      config.puppeteerClusterOptions.puppeteer = puppeteer;
      config.puppeteerOptions.executablePath = chromePath;
      foundChrome = true;
    }
  }
  if (foundChrome) {
    logger.debug("Testing system Chrome installation.");
    const instance2 = await launch$1(config.puppeteerOptions).catch((e) => {
      logger.warn(`Failed to launch puppeteer instance using \`${config.puppeteerOptions?.executablePath}\`.`, e);
      foundChrome = false;
    });
    if (instance2) {
      await instance2.close();
    }
  }
  if (!foundChrome) {
    try {
      await resolve$2("puppeteer");
      foundChrome = true;
      logger.info("Using puppeteer dependency for Chrome.");
    } catch (e) {
      logger.debug("Puppeteer does not exist as a dependency.", e);
    }
  }
  if (config.chrome.useDownloadFallback && !foundChrome) {
    const browserOptions = {
      installDeps: process.getuid?.() === 0,
      cacheDir: config.chrome.downloadFallbackCacheDir,
      buildId: config.chrome.downloadFallbackVersion || PUPPETEER_REVISIONS.chrome,
      browser: "chrome"
    };
    const chromePath = computeExecutablePath(browserOptions);
    if (!existsSync(chromePath)) {
      logger.info(`Missing ${browserOptions.browser} binary, downloading v${browserOptions.buildId}...`);
      let lastPercent = 0;
      await install({
        ...browserOptions,
        downloadProgressCallback: (downloadedBytes, toDownloadBytes) => {
          const percent = Math.round(downloadedBytes / toDownloadBytes * 100);
          if (percent % 5 === 0 && lastPercent !== percent) {
            logger.info(`Downloading ${browserOptions.browser}: ${percent}%`);
            lastPercent = percent;
          }
        }
      });
    }
    logger.info(`Using downloaded ${browserOptions.browser} v${browserOptions.buildId} located at: ${chromePath}`);
    config.puppeteerOptions.executablePath = chromePath;
    foundChrome = true;
  }
  if (!foundChrome)
    throw new Error("Failed to find chrome. Please ensure you have a valid chrome installed.");
  const instance = await launch$1(config.puppeteerOptions).catch((e) => {
    if (detectBrowserPlatform() === "linux" && e.toString().includes("error while loading shared libraries")) {
      const depsPath = path.join(
        path.dirname(config.puppeteerOptions.executablePath),
        "deb.deps"
      );
      if (existsSync(depsPath)) {
        const data = readFileSync(depsPath, "utf-8").trim().split("\n").map((d) => `"${d}"`).join(",");
        logger.warn("Failed to start puppeteer, you may be missing dependencies.");
        logger.log("");
        const command = [
          "sudo",
          "apt-get",
          "satisfy",
          "-y",
          data,
          "--no-install-recommends"
        ].join(" ");
        console.log(`\x1B[96m%s\x1B[0m`, `Run the following command:
${command}`);
        logger.log("");
      }
    }
    throw e;
  });
  if (instance) {
    await instance.close();
  }
  config.outputPath = resolve(config.root, config.outputPath);
  return config;
};

const maxCharsPerLine = () => (process.stdout.columns || 100) * 80 / 100;
function indent(count, chr = " ") {
  return chr.repeat(count);
}
function indentLines(string, spaces, firstLineSpaces) {
  const lines = Array.isArray(string) ? string : string.split("\n");
  let s = "";
  if (lines.length) {
    const i0 = indent(firstLineSpaces);
    s = i0 + lines.shift();
  }
  if (lines.length) {
    const i = indent(spaces);
    s += `
${lines.map((l) => i + l).join("\n")}`;
  }
  return s;
}
function foldLines(string, spaces, firstLineSpaces, charsPerLine = maxCharsPerLine()) {
  return indentLines(wrapAnsi(string, charsPerLine), spaces, firstLineSpaces);
}
function box(message, title, options) {
  return `${box$1([
    title,
    "",
    colorize("white", foldLines(message, 0, 0, maxCharsPerLine()))
  ].join("\n"), Object.assign({
    borderColor: "white",
    borderStyle: "round",
    padding: 1,
    margin: 1
  }, options))}
`;
}
function successBox(message, title) {
  return box(message, title, {
    style: {
      borderColor: "green"
    }
  });
}

const engineContext = createContext();
const useUnlighthouse = engineContext.tryUse;
function defineConfig(config) {
  return config;
}
async function createUnlighthouse(userConfig, provider) {
  const logger = createLogger(userConfig.debug);
  const { __dirname } = createCommonJS(import.meta.url);
  if (userConfig.root && !isAbsolute(userConfig.root))
    userConfig.root = join(process.cwd(), userConfig.root);
  else if (!userConfig.root)
    userConfig.root = process.cwd();
  logger.debug(`Starting Unlighthouse at root: \`${userConfig.root}\` cwd: ${process.cwd()}`);
  globalThis.defineUnlighthouseConfig = (c) => c;
  const { configFile, config } = await loadConfig({
    name: "unlighthouse",
    configFile: userConfig.configFile || "unlighthouse.config",
    dotenv: true
  });
  delete globalThis.defineUnlighthouseConfig;
  logger.debug("Discovered config definition", config);
  userConfig = defu(config, userConfig);
  const runtimeSettings = {
    configFile: configFile || void 0,
    moduleWorkingDir: __dirname,
    configCacheKey: "",
    lighthouseProcessPath: ""
  };
  runtimeSettings.lighthouseProcessPath = await resolvePath(
    join(runtimeSettings.moduleWorkingDir, "process", "lighthouse.mjs")
  ).catch(() => "");
  if (!await fs.pathExists(runtimeSettings.lighthouseProcessPath)) {
    runtimeSettings.lighthouseProcessPath = await resolvePath(
      join(runtimeSettings.moduleWorkingDir, "process", "lighthouse.ts")
    );
  }
  runtimeSettings.configCacheKey = objectHash({ ...userConfig, version }).substring(0, 4);
  const resolvedConfig = await resolveUserConfig(userConfig);
  logger.debug("Post config resolution", resolvedConfig);
  const hooks = createHooks();
  if (resolvedConfig.hooks)
    hooks.addHooks(resolvedConfig.hooks);
  await hooks.callHook("resolved-config", resolvedConfig);
  if (configFile)
    logger.info(`Creating Unlighthouse ${configFile ? `using config from \`${configFile}\`` : ""}`);
  const ws = provider?.name === "ci" ? null : new WS();
  const ctx = {
    runtimeSettings,
    hooks,
    resolvedConfig,
    ws,
    provider
  };
  engineContext.set(ctx, true);
  const tasks = {
    inspectHtmlTask,
    runLighthouseTask
  };
  const worker = await createUnlighthouseWorker(tasks);
  if (resolvedConfig.hooks?.authenticate) {
    await worker.cluster.execute({}, async (taskCtx) => {
      logger.debug("Running authentication hook");
      await taskCtx.page.setBypassCSP(true);
      await hooks.callHook("authenticate", taskCtx.page);
      const localStorageData = await taskCtx.page.evaluate(() => {
        const json = {};
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key)
            json[key] = localStorage.getItem(key);
        }
        return json;
      }).catch((e) => {
        logger.warn("Failed to collect authentication localStorage.\n", e);
        return {};
      });
      const sessionStorageData = await taskCtx.page.evaluate(() => {
        const json = {};
        for (let i = 0; i < sessionStorage.length; i++) {
          const key = sessionStorage.key(i);
          if (key)
            json[key] = sessionStorage.getItem(key);
        }
        return json;
      }).catch((e) => {
        logger.warn("Failed to collect authentication sessionStorage.\n", e);
        return {};
      });
      const cookies = await taskCtx.page.cookies();
      logger.debug("Authentication completed", { cookies, localStorageData, sessionStorageData });
      ctx.resolvedConfig.cookies = [...ctx.resolvedConfig.cookies || [], ...cookies];
      ctx.resolvedConfig.localStorage = { ...ctx.resolvedConfig.localStorage, ...localStorageData };
      ctx.resolvedConfig.sessionStorage = { ...ctx.resolvedConfig.sessionStorage, ...sessionStorageData };
    });
  }
  ctx.worker = worker;
  ctx.setCiContext = async () => {
    const $site = new $URL(resolvedConfig.site);
    logger.debug(`Setting Unlighthouse CI Context [Site: ${$site}]`);
    let outputPath = join(
      resolvedConfig.outputPath,
      // fix windows not supporting : in paths
      $site.hostname.replace(":", "\uA789"),
      runtimeSettings.configCacheKey || ""
    );
    try {
      await fs.mkdir(resolvedConfig.outputPath, { recursive: true });
    } catch (e) {
      logger.error(`Failed to create output directory. Please check unlighthouse has permissions to: ${resolvedConfig.outputPath}`, e);
    }
    try {
      await fs.mkdir(outputPath, { recursive: true });
    } catch (e) {
      logger.error(`Failed to create output directory. Please check unlighthouse has permission to create files and folders in: ${resolvedConfig.outputPath}`, e);
    }
    if (provider?.name === "ci")
      outputPath = resolvedConfig.outputPath;
    ctx.runtimeSettings = {
      ...ctx.runtimeSettings,
      outputPath,
      generatedClientPath: outputPath,
      resolvedClientPath: await resolvePath(ClientPkg, { url: import.meta.url })
    };
    if (!resolvedConfig.cache && existsSync(resolvedConfig.outputPath)) {
      logger.debug(`\`cache\` is disabled, deleting cache folder: \`${resolvedConfig.outputPath}\``);
      fs.rmSync(outputPath, { recursive: true });
    }
    fs.ensureDirSync(ctx.runtimeSettings.outputPath);
    return ctx;
  };
  ctx.setSiteUrl = async (url) => {
    const site = normaliseHost(url);
    ctx.runtimeSettings.siteUrl = site;
    logger.debug(`Setting Unlighthouse Site URL [Site: ${site.toString()}]`);
    const outputPath = join(
      resolvedConfig.outputPath,
      // fix windows not supporting : in paths
      runtimeSettings.siteUrl?.hostname.replace(":", "\uA789") || "",
      runtimeSettings.configCacheKey || ""
    );
    if (!ctx.resolvedConfig.site)
      ctx.resolvedConfig.site = site.toString();
    ctx.runtimeSettings.outputPath = outputPath;
    ctx.runtimeSettings.generatedClientPath = outputPath;
    await hooks.callHook("site-changed", ctx.resolvedConfig.site);
  };
  ctx.setServerContext = async ({ url, server, app }) => {
    const $server = new URL(url);
    logger.debug(`Setting Unlighthouse Server Context [Server: ${$server}]`);
    const clientUrl = joinURL($server.toString(), resolvedConfig.routerPrefix);
    const apiPath = joinURL(resolvedConfig.routerPrefix, resolvedConfig.apiPrefix);
    ctx.runtimeSettings.serverUrl = url;
    ctx.runtimeSettings = {
      ...ctx.runtimeSettings,
      apiPath,
      server,
      resolvedClientPath: await resolvePath(ClientPkg, { url: import.meta.url }),
      clientUrl,
      apiUrl: joinURL($server.toString(), apiPath),
      websocketUrl: `ws://${joinURL($server.host, apiPath, "/ws")}`
    };
    ctx.api = await createApi(app);
    if (ws) {
      server.on("upgrade", (request, socket) => {
        ws.handleUpgrade(request, socket);
      });
    }
    if (!resolvedConfig.cache && existsSync(ctx.runtimeSettings.outputPath)) {
      logger.debug(`\`cache\` is disabled, deleting cache folder: \`${ctx.runtimeSettings.outputPath}\``);
      try {
        fs.rmSync(ctx.runtimeSettings.outputPath, { recursive: true });
      } catch (e) {
        logger.debug(`Failed to delete cache folder: \`${ctx.runtimeSettings.outputPath}\``, e);
      }
    }
    fs.ensureDirSync(ctx.runtimeSettings.outputPath);
    await generateClient();
    if (provider?.name !== "cli") {
      hooks.hookOnce("visited-client", () => {
        ctx.start();
      });
    }
    return ctx;
  };
  ctx.start = async () => {
    logger.debug(`Starting Unlighthouse [Server: ${provider?.name === "ci" ? "N/A" : ctx.runtimeSettings.clientUrl} Site: ${ctx.resolvedConfig.site} Debug: \`${ctx.resolvedConfig.debug}\`]`);
    if (typeof provider?.routeDefinitions === "function")
      ctx.routeDefinitions = await provider.routeDefinitions();
    else
      ctx.routeDefinitions = provider?.routeDefinitions;
    if (!ctx.routeDefinitions && resolvedConfig.discovery !== false) {
      logger.debug("No route definitions provided, discovering them ourselves.");
      ctx.routeDefinitions = await discoverRouteDefinitions();
    }
    if (ctx.routeDefinitions?.length) {
      ctx.provider = ctx.provider || {};
      if (typeof ctx.provider?.mockRouter === "function")
        ctx.provider.mockRouter = ctx.provider.mockRouter(ctx.routeDefinitions);
      else if (!ctx.provider.mockRouter)
        ctx.provider.mockRouter = createMockRouter(ctx.routeDefinitions);
      logger.debug(`Discovered ${ctx.routeDefinitions?.length} definitions and setup mock router.`);
    }
    ctx.routes = await resolveReportableRoutes();
    logger.debug("Resolved reportable routes", ctx.routes.length);
    createBroadcastingEvents();
    worker.queueRoutes(ctx.routes);
    if (provider?.name !== "ci") {
      const label = (name) => colorize("bold", colorize("magenta", `\u25B8 ${name}:`));
      let mode = "";
      if (resolvedConfig.urls?.length)
        mode = "Manual";
      if (resolvedConfig.scanner.sitemap !== false)
        mode += "Sitemap";
      if (resolvedConfig.scanner.crawler)
        mode += mode.length > 0 ? " + Crawler" : "Crawler";
      let latestTag = `v${version}`;
      try {
        latestTag = (await $fetch("https://ungh.unjs.io/repos/harlan-zw/unlighthouse/releases/latest")).release.tag;
      } catch {
      }
      const title = [
        `\u26F5\u200D  ${colorize("bold", colorize("blueBright", AppName))} ${colorize("dim", `${provider?.name} @ v${version}`)}`
      ];
      if (Number(latestTag.replace("v", "").replace(".", "")) > Number(version.replace(".", ""))) {
        title.push(...[
          "",
          `\u{1F389} New version ${latestTag} available! Use the latest:`,
          colorize("gray", ` > ${colorize("underline", `npx unlighthouse@^${latestTag} --site ${resolvedConfig.site}`)}`)
        ]);
      }
      title.push(...[
        "",
        `${label("Scanning")} ${resolvedConfig.site}`,
        `${label("Route Discovery")} ${mode} ${ctx.routes.length > 1 ? colorize("dim", `${ctx.routes.length} initial URLs`) : ""}`,
        "",
        colorize("dim", " \u{1F496} Like Unlighthouse? Support the development: https://github.com/sponsors/harlan-zw")
      ]);
      if (ctx.routeDefinitions?.length)
        title.push(`${label("Route Definitions")} ${ctx.routeDefinitions.length}`);
      process.stdout.write(successBox(
        // messages
        [
          ctx.runtimeSettings.clientUrl ? colorize("whiteBright", `Report: ${ctx.runtimeSettings.clientUrl}`) : ""
        ].join("\n"),
        // title
        title.join("\n")
      ));
      if (existsSync(join(ctx.runtimeSettings.generatedClientPath, "reports", "lighthouse.json")) && ctx.resolvedConfig.cache)
        logger.info(`Restoring reports from cache. ${colorize("gray", "You can disable this behavior by passing --no-cache.")}`);
    }
    return ctx;
  };
  if (ctx.resolvedConfig.site)
    ctx.setSiteUrl(resolvedConfig.site);
  return ctx;
}

const ReportArtifacts = {
  html: "payload.html",
  reportHtml: "lighthouse.html",
  screenshot: "screenshot.jpeg",
  fullScreenScreenshot: "full-screenshot.jpeg",
  screenshotThumbnailsDir: "__screenshot-thumbnails__",
  reportJson: "lighthouse.json"
};
const trimSlashes = (s) => withoutLeadingSlash(withoutTrailingSlash(s));
const withSlashes = (s) => withLeadingSlash(withTrailingSlash(s)) || "/";
function sanitiseUrlForFilePath(url) {
  url = trimSlashes(url);
  if (url.endsWith(".html"))
    url = url.replace(/\.html$/, "");
  return url.split("/").map((part) => sanitize(slugify(part))).join("/");
}
function hashPathName(path) {
  return createHash("md5").update(sanitiseUrlForFilePath(path)).digest("hex").substring(0, 6);
}
function normaliseHost(host) {
  if (!host.startsWith("http"))
    host = `http${host.startsWith("localhost") ? "" : "s"}://${host}`;
  host = host.includes(".") ? host : withTrailingSlash(host);
  return new URL(host);
}
function createTaskReportFromRoute(route) {
  const { runtimeSettings, resolvedConfig } = useUnlighthouse();
  const reportId = hashPathName(route.path);
  const reportPath = join(runtimeSettings.generatedClientPath, "reports", sanitiseUrlForFilePath(route.path));
  ensureDirSync(reportPath);
  return {
    tasks: {
      runLighthouseTask: "waiting",
      inspectHtmlTask: "waiting"
    },
    route,
    reportId,
    artifactPath: reportPath,
    artifactUrl: joinURL(resolvedConfig.routerPrefix, "reports", sanitiseUrlForFilePath(route.path))
  };
}
function base64ToBuffer(dataURI) {
  return Buffer.from(dataURI.split(",")[1], "base64");
}
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0)
    return "0 Bytes";
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${Number.parseFloat((bytes / k ** i).toFixed(dm))} ${sizes[i]}`;
}
const _sharedContext = {};
function sharedContext() {
  return useUnlighthouse() || _sharedContext;
}
async function createAxiosInstance(resolvedConfig) {
  dns.setServers([
    "8.8.8.8",
    // Google
    "1.1.1.1"
    // Cloudflare
  ]);
  const resolver = new dns.Resolver();
  resolver.setServers([
    "8.8.8.8",
    // Google
    "1.1.1.1"
    // Cloudflare
  ]);
  const axiosOptions = {};
  if (resolvedConfig.auth)
    axiosOptions.auth = resolvedConfig.auth;
  axiosOptions.headers = axiosOptions.headers || {};
  if (resolvedConfig.cookies) {
    axiosOptions.headers.Cookie = resolvedConfig.cookies.map((cookie) => `${cookie.name}=${cookie.value}`).join("; ");
  }
  const userAgent = resolvedConfig.userAgent || resolvedConfig.lighthouseOptions.emulatedUserAgent || "Unlighthouse";
  axiosOptions.headers = {
    // fallback user agent, allow overriding
    "User-Agent": userAgent,
    ...resolvedConfig.extraHeaders || {},
    ...axiosOptions.headers
  };
  if (resolvedConfig.defaultQueryParams)
    axiosOptions.params = { ...resolvedConfig.defaultQueryParams, ...axiosOptions.params };
  axiosOptions.httpsAgent = new https.Agent({
    rejectUnauthorized: false,
    keepAlive: true,
    timeout: 3e4
  });
  axiosOptions.httpAgent = new http.Agent({
    keepAlive: true,
    timeout: 3e4
  });
  axiosOptions.proxy = false;
  axiosOptions.timeout = 3e4;
  axiosOptions.withCredentials = true;
  const unlighthouse = sharedContext();
  unlighthouse._axios = axios.create(axiosOptions);
  return unlighthouse._axios;
}
async function fetchUrlRaw(url, resolvedConfig) {
  const logger = useLogger();
  const unlighthouse = sharedContext();
  const instance = unlighthouse._axios || await createAxiosInstance(resolvedConfig);
  const maxRetries = 3;
  let attempt = 0;
  while (attempt < maxRetries) {
    try {
      const response = await instance.get(url, { timeout: 3e4 });
      let responseUrl = response.request.res.responseUrl;
      if (responseUrl && resolvedConfig.auth) {
        responseUrl = responseUrl.replace(/(?<=https?:\/\/)(.+?@)/g, "");
      }
      const redirected = responseUrl && responseUrl !== url;
      const redirectUrl = responseUrl;
      if (response.status < 200 || response.status >= 300 && !redirected) {
        return {
          valid: false,
          redirected,
          response,
          redirectUrl
        };
      }
      return {
        valid: true,
        redirected,
        response,
        redirectUrl
      };
    } catch (e) {
      if (e.errors) {
        logger.error("Axios error:", e.errors);
      }
      logger.error("Axios error message:", e.message);
      logger.error("Axios error code:", e.code);
      if (e.response) {
        logger.error("Axios error response data:", e.response.data);
        logger.error("Axios error response status:", e.response.status);
        logger.error("Axios error response headers:", e.response.headers);
      }
      if (e.code === "ETIMEDOUT" || e.code === "ENETUNREACH") {
        attempt++;
        logger.info(`Retrying request... (${attempt}/${maxRetries})`);
        continue;
      }
      return {
        error: e,
        valid: false
      };
    }
  }
  return {
    error: new Error("Max retries reached"),
    valid: false
  };
}

export { ReportArtifacts, createUnlighthouse, defineConfig, fetchUrlRaw, generateClient, normaliseHost, useLogger, useUnlighthouse };
