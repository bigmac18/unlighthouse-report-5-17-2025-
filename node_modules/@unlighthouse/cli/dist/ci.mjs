import { setMaxListeners } from 'node:events';
import { createUnlighthouse, useUnlighthouse, useLogger, generateClient } from '@unlighthouse/core';
import fse from 'fs-extra';
import { relative } from 'pathe';
import { isCI } from 'std-env';
import { h as handleError, c as createCli, p as pickOptions, v as validateHost, a as validateOptions } from './shared/cli.CpWxFivj.mjs';
import { join } from 'node:path';
import { get } from 'lodash-es';
import ApiClient from '@lhci/utils/src/api-client.js';
import { getCurrentHash, getCurrentBranch, getAncestorHash, getCommitTime, getExternalBuildUrl, getAvatarUrl, getAuthor, getCommitMessage } from '@lhci/utils/src/build-context.js';
import 'cac';
import 'node:url';
import 'defu';
import 'consola';

function escapeValueForCsv(value) {
  if (typeof value === "number" || typeof value === "boolean")
    return String(value);
  return `"${value.replace(/"/g, '""')}"`;
}
function csvSimpleFormat(reports) {
  const headers = ["URL", "Score"];
  Object.values(reports[0].report.categories).forEach((category) => {
    headers.push(category.title);
  });
  const body = reports.map(({ report, route }) => {
    const topLevelScoreKeys = [];
    Object.keys(report.categories).forEach((category) => {
      topLevelScoreKeys.push(Math.round(report.categories[category].score * 100));
    });
    return [
      route.path,
      Math.round(report.score * 100),
      // list all top level scores (performance, accessibility, etc)
      ...topLevelScoreKeys
    ].map(escapeValueForCsv);
  });
  return {
    headers,
    body
  };
}
function reportCSVSimple(reports) {
  const { headers, body } = csvSimpleFormat(reports);
  return [
    headers.join(","),
    ...body.map((row) => row.join(","))
  ].flat().join("\n");
}

function reportCSVExpanded(reports, { columns }) {
  const { headers, body } = csvSimpleFormat(reports);
  for (const k of Object.keys(columns)) {
    if (k === "overview")
      continue;
    if (!reports[0].report.categories.find((category) => category.key === k))
      continue;
    headers.push(
      ...columns[k].map((column) => ({
        column,
        val: get(reports[0], column.key)
      })).filter(({ val }) => val?.scoreDisplayMode && val.scoreDisplayMode !== "informative" && val.scoreDisplayMode !== "notApplicable").map(({ column }) => column.label)
    );
  }
  reports.forEach(({ report }, i) => {
    for (const k of Object.keys(columns)) {
      if (k === "overview")
        continue;
      if (!reports[0].report.categories.find((category) => category.key === k))
        continue;
      body[i].push(
        ...columns[k].map((column) => get(report, column.key.replace("report.", ""))).filter((val) => val?.scoreDisplayMode && val.scoreDisplayMode !== "informative" && val.scoreDisplayMode !== "notApplicable").map((val) => {
          if (val.scoreDisplayMode === "binary")
            return val.score;
          if (val.scoreDisplayMode === "numeric")
            return Math.round(val.numericValue * 100) / 100;
          return val.score;
        })
      );
    }
  });
  return [
    headers.join(","),
    ...body.map((row) => row.join(","))
  ].flat().join("\n");
}

const relevantMetrics = [
  "largest-contentful-paint",
  "cumulative-layout-shift",
  "first-contentful-paint",
  "total-blocking-time",
  "max-potential-fid",
  "interactive"
];
function reportJsonExpanded(reports) {
  let metadata = {
    metrics: {},
    categories: {}
  };
  const routes = reports.map((report) => {
    const categories = Object.values(report.report?.categories ?? {}).reduce(
      (prev, category) => {
        metadata = {
          ...metadata,
          categories: {
            ...metadata.categories,
            [category.key]: {
              id: category.id,
              title: category.title
            }
          }
        };
        return {
          ...prev,
          [category.key]: {
            score: category.score
          }
        };
      },
      {}
    );
    const metrics = Object.values(report.report?.audits ?? {}).filter((metric) => relevantMetrics.includes(metric.id)).reduce((prev, metric) => {
      metadata = {
        ...metadata,
        metrics: {
          ...metadata.metrics,
          [metric.id]: {
            id: metric.id,
            title: metric.title,
            description: metric.description,
            numericUnit: metric.numericUnit
          }
        }
      };
      return {
        ...prev,
        [metric.id]: {
          numericValue: metric.numericValue,
          displayValue: metric.displayValue
        }
      };
    }, {});
    return {
      path: report.route.path,
      score: report.report?.score,
      categories,
      metrics
    };
  }).sort((a, b) => a.path.localeCompare(b.path));
  const averageCategories = extractCategoriesFromRoutes(routes);
  const averageMetrics = extractMetricsFromRoutes(routes);
  const summary = {
    score: Number.parseFloat(
      (routes.reduce((prev, curr) => prev + curr.score, 0) / routes.length).toFixed(2)
    ),
    categories: averageCategories,
    metrics: averageMetrics
  };
  return {
    summary,
    routes,
    metadata
  };
}
function extractCategoriesFromRoutes(routes) {
  const categoriesWithAllScores = routes.reduce((prev, curr) => {
    return Object.keys(curr.categories).reduce((target, categoryKey) => {
      const scores = target[categoryKey] ? target[categoryKey].scores : [];
      const { ...strippedCategory } = curr.categories[categoryKey];
      return {
        ...target,
        [categoryKey]: {
          ...strippedCategory,
          scores: [...scores, curr.categories[categoryKey].score]
        }
      };
    }, prev);
  }, {});
  return Object.keys(categoriesWithAllScores).reduce(
    (prev, key) => {
      const averageScore = Number.parseFloat(
        (categoriesWithAllScores[key].scores.reduce(
          (prev2, curr) => prev2 + curr,
          0
        ) / categoriesWithAllScores[key].scores.length).toFixed(2)
      );
      const { ...strippedCategory } = categoriesWithAllScores[key];
      return { ...prev, [key]: { ...strippedCategory, averageScore } };
    },
    {}
  );
}
function extractMetricsFromRoutes(routes) {
  const metricsWithAllNumericValues = routes.reduce((prev, curr) => {
    return Object.keys(curr.metrics).reduce((target, metricKey) => {
      const numericValues = target[metricKey] ? target[metricKey].numericValues : [];
      const { ...strippedMetric } = curr.metrics[metricKey];
      return {
        ...target,
        [metricKey]: {
          ...strippedMetric,
          numericValues: [...numericValues, curr.metrics[metricKey].numericValue]
        }
      };
    }, prev);
  }, {});
  return Object.keys(metricsWithAllNumericValues).reduce(
    (prev, key) => {
      const averageNumericValue = Number.parseFloat(
        (metricsWithAllNumericValues[key].numericValues.reduce(
          (prev2, curr) => prev2 + curr,
          0
        ) / metricsWithAllNumericValues[key].numericValues.length).toFixed(2)
      );
      const { ...strippedMetric } = metricsWithAllNumericValues[key];
      return { ...prev, [key]: { ...strippedMetric, averageNumericValue } };
    },
    {}
  );
}

function reportJsonSimple(reports) {
  return reports.map((report) => {
    const scores = {};
    Object.values(report.report.categories).forEach((category) => {
      scores[category.key] = category.score;
    });
    return {
      path: report.route.path,
      score: report.report?.score,
      ...scores
    };
  });
}

async function reportLighthouseServer(reports, { lhciBuildToken, lhciHost, lhciAuth }) {
  try {
    const api = new ApiClient({
      fetch,
      rootURL: lhciHost,
      basicAuth: typeof lhciAuth === "string" && lhciAuth.includes(":") ? { username: lhciAuth.split(":")[0], password: lhciAuth.split(":")[1] } : void 0
    });
    api.setBuildToken(lhciBuildToken);
    const project = await api.findProjectByToken(lhciBuildToken);
    const baseBranch = project.baseBranch || "master";
    const hash = getCurrentHash();
    const branch = getCurrentBranch();
    const ancestorHash = getAncestorHash("HEAD", baseBranch);
    const build = await api.createBuild({
      projectId: project.id,
      lifecycle: "unsealed",
      hash,
      branch,
      ancestorHash,
      commitMessage: getCommitMessage(hash),
      author: getAuthor(hash),
      avatarUrl: getAvatarUrl(hash),
      externalBuildUrl: getExternalBuildUrl(),
      runAt: (/* @__PURE__ */ new Date()).toISOString(),
      committedAt: getCommitTime(hash),
      ancestorCommittedAt: ancestorHash ? getCommitTime(ancestorHash) : void 0
    });
    for (const report of reports) {
      const lighthouseResult = await fse.readJson(
        `${report.artifactPath}/lighthouse.json`
      );
      await api.createRun({
        projectId: project.id,
        buildId: build.id,
        representative: false,
        url: `${report.route.url}${report.route.path}`,
        lhr: JSON.stringify(lighthouseResult)
      });
    }
    await api.sealBuild(build.projectId, build.id);
  } catch (e) {
    handleError(e);
  }
}

function generateReportPayload(reporter, _reports, config) {
  const reports = _reports.sort((a, b) => a.route.path.localeCompare(b.route.path)).filter((r) => {
    if (!r.report?.categories)
      return false;
    return r.report.audits;
  });
  if (reporter.startsWith("json")) {
    if (reporter === "jsonSimple" || reporter === "json")
      return reportJsonSimple(reports);
    if (reporter === "jsonExpanded")
      return reportJsonExpanded(reports);
  }
  if (reporter.startsWith("csv")) {
    if (reporter === "csvSimple" || reporter === "csv")
      return reportCSVSimple(reports);
    if (reporter === "csvExpanded")
      return reportCSVExpanded(reports, config);
  }
  if (reporter === "lighthouseServer")
    return reportLighthouseServer(reports, config);
  throw new Error(`Unsupported reporter: ${reporter}.`);
}
async function outputReport(reporter, config, payload) {
  if (reporter.startsWith("json")) {
    const path = join(config.outputPath, "ci-result.json");
    await fse.writeJson(path, payload, { spaces: 2 });
    return path;
  }
  if (reporter.startsWith("csv")) {
    const path = join(config.outputPath, "ci-result.csv");
    await fse.writeFile(path, payload);
    return path;
  }
  throw new Error(`Unsupported reporter: ${reporter}.`);
}

async function run() {
  const startTime = /* @__PURE__ */ new Date();
  setMaxListeners(0);
  const cli = createCli();
  cli.option("--budget <budget>", "Budget (1-100), the minimum score which can pass.");
  cli.option("--build-static <build-static>", "Build a static website for the reports which can be uploaded.");
  cli.option("--reporter <reporter>", "The report to generate from results. Options: csv, csvExpanded, json, jsonExpanded or false. Default: json.");
  cli.option("--lhci-host <lhci-host>", "URL of your LHCI server.");
  cli.option("--lhci-build-token <lhci-build-token>", "LHCI build token, used to add data.");
  cli.option("--lhci-auth <lhci-auth>", "Basic auth for your LHCI server.");
  const { options } = cli.parse();
  if (options.help || options.version)
    return;
  const resolvedOptions = pickOptions(options);
  resolvedOptions.ci = {
    budget: options.budget || void 0,
    buildStatic: options.buildStatic || false,
    reporter: options.reporter || "jsonSimple",
    reporterConfig: {
      lhciHost: options.lhciHost,
      lhciBuildToken: options.lhciBuildToken,
      lhciAuth: options.lhciAuth
    }
  };
  await createUnlighthouse({
    ...resolvedOptions,
    hooks: {
      "resolved-config": async (config) => {
        await validateHost(config);
      }
    },
    cache: false
  }, { name: "ci" });
  const { resolvedConfig, setCiContext, hooks, worker, start } = useUnlighthouse();
  validateOptions(resolvedConfig);
  const logger = useLogger();
  let hasBudget = true;
  if (!resolvedConfig.ci?.budget)
    hasBudget = false;
  await setCiContext();
  const { routes } = await start();
  if (!routes.length) {
    logger.error("Failed to queue routes for scanning. Please check the logs with debug enabled.");
    process.exit(1);
  }
  hooks.hook("worker-finished", async () => {
    const end = /* @__PURE__ */ new Date();
    const seconds = Math.round((end.getTime() - startTime.getTime()) / 1e3);
    logger.success(`Unlighthouse has finished scanning \`${resolvedConfig.site}\`: ${worker.reports().length} routes in \`${seconds}s\`.`);
    let hadError = false;
    if (hasBudget) {
      logger.info("Running score budgets.", resolvedConfig.ci.budget);
      worker.reports().forEach((report) => {
        const categories = report.report?.categories;
        if (!categories)
          return;
        Object.values(categories).forEach((category) => {
          let budget = resolvedConfig.ci.budget;
          if (!Number.isInteger(budget))
            budget = resolvedConfig.ci.budget[category.key];
          if (category.score && category.score * 100 < budget) {
            logger.error(
              `${report.route.path} has invalid score \`${category.score}\` for category \`${category.key}\`.`
            );
            hadError = true;
          }
        });
      });
      if (!hadError)
        logger.success("Score assertions have passed.");
    }
    if (resolvedConfig.ci.reporter) {
      const reporter = resolvedConfig.ci.reporter;
      const reporterConfig = {
        columns: resolvedConfig.client.columns,
        ...resolvedConfig.ci?.reporterConfig || {}
      };
      const payload = await Promise.resolve(generateReportPayload(reporter, worker.reports(), reporterConfig));
      let path = "";
      if (payload)
        path = `\`./${relative(resolvedConfig.root, await outputReport(reporter, resolvedConfig, payload))}\``;
      logger.success(`Generated \`${resolvedConfig.ci.reporter}\` report`, path);
    }
    if (resolvedConfig.ci?.buildStatic) {
      logger.info("Generating static report.");
      const { runtimeSettings, resolvedConfig: resolvedConfig2 } = useUnlighthouse();
      await generateClient({ static: true });
      const globby = await import('globby');
      const jsonPayloads = await globby.globby(
        ["lighthouse.json", "**/lighthouse.json", "assets/lighthouse.fbx"],
        { cwd: runtimeSettings.generatedClientPath, absolute: true }
      );
      logger.debug(
        `Deleting ${jsonPayloads.length} files not required for static build.`
      );
      for (const k in jsonPayloads) await fse.rm(jsonPayloads[k]);
      const relativeDir = `./${relative(resolvedConfig2.root, runtimeSettings.generatedClientPath)}`;
      logger.success(`Static report is ready for uploading: \`${relativeDir}\``);
      if (!isCI) {
        logger.info(`You can preview the static report using \`npx sirv-cli ${relativeDir}\`.`);
        logger.info("For deployment demos, see https://unlighthouse.dev/guide/guides/generating-static-reports#interactive-html-reports");
      }
    }
    process.exit(hadError ? 1 : 0);
  });
}
run().catch(handleError);
