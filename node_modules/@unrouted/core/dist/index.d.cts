import * as h3 from 'h3';
import { EventHandler, H3Event, Router, RouterMethod, CompatibilityEventHandler, HTTPMethod, H3Error } from 'h3';
import { Hookable } from 'hookable';
import { ConsolaInstance } from 'consola';
import { Import } from 'unimport';
import { QueryObject } from 'ufo';

type Nullable$1<T> = {
    [K in keyof T]: T[K] | null;
};
type HookResult<T = void> = Promise<T> | T;
interface UnroutedHooks {
    'setup:after': (ctx: UnroutedContext) => HookResult;
    'setup:before': (ctx: UnroutedContext) => HookResult;
    'setup:routes': (routes: Route[]) => HookResult;
    'response:before': (handler: EventHandler, payload: any) => HookResult;
    'request:handle:before': (e: H3Event) => HookResult;
    'request:error:404': (e: H3Event) => HookResult;
}
type UnroutedEventHandler = EventHandler | string;
type UnroutedHookable = Hookable<UnroutedHooks>;
type SimpleOptions = Record<string, any>;
interface UnroutedPlugin<T> {
    defaults?: T extends any ? (Partial<T> | ((ctx: UnroutedContext) => Partial<T>)) : never;
    meta: {
        name: string;
        version?: string;
    };
    setup: (ctx: UnroutedContext, resolvedOptions: T) => Promise<any> | any;
}
interface UnroutedPreset<T> extends UnroutedPlugin<T> {
}
interface UnroutedMiddleware<T> extends UnroutedPlugin<T> {
}
interface ResolvedPlugin {
    meta: {
        name: string;
        version?: string;
    };
    setup: (ctx: UnroutedContext) => Promise<any> | any;
}
interface ResolvedConfig {
    app?: any;
    prefix: string;
    name: string;
    debug: boolean;
    presets: ResolvedPlugin[];
    plugins: ResolvedPlugin[];
    middleware: EventHandler[];
    hooks: Partial<UnroutedHooks>;
}
type DeepPartial<T> = T extends Function ? T : (T extends object ? {
    [P in keyof T]?: DeepPartial<T[P]>;
} : T);
type NormaliseRouteFn = (method: HttpMethodInput, urlPattern: string, handle: UnroutedEventHandler, meta?: RouteMeta) => Route;
type RegisterRouteFn = (method: HttpMethodInput, urlPattern: string, handle: UnroutedEventHandler, meta?: RouteMeta) => Route;
type ConfigPartial = DeepPartial<ResolvedConfig>;
interface GroupAttributes {
    middleware?: UnroutedEventHandler[];
    prefix?: string;
    controller?: any;
    routeMeta?: RouteMeta;
}
interface UnroutedContext {
    /**
     * Runtime configuration for the current prefix path.
     */
    groupStack: GroupAttributes[];
    /**
     * Resolved configuration.
     */
    config: ResolvedConfig;
    /**
     * Function used to handle a request for the Unrouted instance.
     * This should be passed to a server such as h3, connect, express, koa, etc.
     */
    app: any;
    /**
     * A flat copy of the normalised routes being used.
     */
    routes: Route[];
    router: Router;
    /**
     * The logger instance. Will be Consola if available, otherwise console.
     */
    logger: ConsolaInstance;
    /**
     * The hookable instance, allows hooking into core functionality.
     */
    hooks: UnroutedHookable;
    /**
     * Composable setup function for declaring routes.
     * @param fn
     */
    setup: (fn?: () => void) => Promise<void>;
}
type HttpMethodInput = RouterMethod | RouterMethod[];
interface RouteMeta {
    id?: string;
    resolve?: {
        module?: unknown;
        file?: string;
        import?: Import;
        fn?: string;
    };
    middleware?: UnroutedEventHandler[];
    parameterMatchRegExps?: Record<string, RegExp>;
    runtimeTypes?: string;
}
interface Route {
    id: string;
    path: string;
    handle: UnroutedEventHandler;
    method: RouterMethod[];
    meta: RouteMeta;
}
interface GetRoutes {
}
interface PostRoutes {
}
interface PutRoutes {
}
interface PatchRoutes {
}
interface DeleteRoutes {
}
interface OptionsRoutes {
}
interface RouteSchema {
    get: GetRoutes;
    post: PostRoutes;
    put: PutRoutes;
    patch: PatchRoutes;
    delete: DeleteRoutes;
    options: OptionsRoutes;
}

declare const useEvent: () => H3Event;
declare const useUnrouted: () => UnroutedContext;
declare const useParams: <T>() => T;
declare const useBody: <T>() => Nullable$1<T>;
declare function createUnrouted(config?: ConfigPartial): Promise<UnroutedContext>;

/**
 * A simple define wrapper to provide typings to config definitions.
 * @param config
 */
declare function defineConfig(config: ConfigPartial): {
    app?: any;
    prefix?: string | undefined;
    name?: string | undefined;
    debug?: boolean | undefined;
    presets?: ({
        meta?: {
            name?: string | undefined;
            version?: string | undefined;
        } | undefined;
        setup?: ((ctx: UnroutedContext) => any) | undefined;
    } | undefined)[] | undefined;
    plugins?: ({
        meta?: {
            name?: string | undefined;
            version?: string | undefined;
        } | undefined;
        setup?: ((ctx: UnroutedContext) => any) | undefined;
    } | undefined)[] | undefined;
    middleware?: (h3.EventHandler<h3.EventHandlerRequest, any> | undefined)[] | undefined;
    hooks?: {
        'setup:after'?: ((ctx: UnroutedContext) => HookResult<void>) | undefined;
        'setup:before'?: ((ctx: UnroutedContext) => HookResult<void>) | undefined;
        'setup:routes'?: ((routes: Route[]) => HookResult<void>) | undefined;
        'response:before'?: ((handler: h3.EventHandler<h3.EventHandlerRequest, any>, payload: any) => HookResult<void>) | undefined;
        'request:handle:before'?: ((e: h3.H3Event<h3.EventHandlerRequest>) => HookResult<void>) | undefined;
        'request:error:404'?: ((e: h3.H3Event<h3.EventHandlerRequest>) => HookResult<void>) | undefined;
    } | undefined;
};
/**
 * A provided configuration from the user may require runtime transformations to avoid breaking app functionality.
 * @param config
 */
declare const resolveConfig: (config: ConfigPartial) => Promise<ResolvedConfig>;

declare function defineUnroutedPlugin<T extends SimpleOptions = SimpleOptions>(plugin: UnroutedPlugin<T>): (options?: Partial<T>) => ResolvedPlugin;
declare function defineUnroutedPreset<T extends SimpleOptions = SimpleOptions>(preset: UnroutedPreset<T>): (options?: Partial<T> | undefined) => ResolvedPlugin;
declare function defineUnroutedMiddleware<T extends SimpleOptions = SimpleOptions>(middleware: UnroutedMiddleware<T>): (options?: Partial<T>) => CompatibilityEventHandler;

declare function resolveStackPrefix(): string;
declare function resolveStackRouteMeta(): {};
declare function unroutedEventHandler(handle: any): EventHandler;
/**
 * Create a normalised route from numerous inputs.
 */
declare const normaliseRoute: NormaliseRouteFn;
/**
 * Registers a route with our router.
 *
 * The route is registered asynchronously to allow for plugins to hook into the registration. This means the route won't
 * be immediately available within the Unrouter context.
 */
declare const registerRoute: RegisterRouteFn;

declare function redirect(route: string, location: string, code?: 301 | 302 | 307 | 410 | 451): void;
declare function permanentRedirect(route: string, location: string): void;

type MatchFn = (methods: RouterMethod, route: string, handle: UnroutedEventHandler) => void;
type RouteMethod = (route: string, handle: UnroutedEventHandler) => Route;
declare const match: MatchFn;
declare const any: RouteMethod;
declare const get: RouteMethod;
declare const post: RouteMethod;
declare const put: RouteMethod;
declare const del: RouteMethod;
declare const head: RouteMethod;
declare const options: RouteMethod;

declare function group(attributes: GroupAttributes, cb: (() => void)): void;
declare function middleware(middleware: EventHandler[], cb: (() => void)): void;
declare function prefix(prefix: string, cb: (() => void)): void;

type Nullable<T> = {
    [K in keyof T]: T[K] | undefined;
};
declare function readRawBody(encoding?: false | 'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'latin1' | 'binary' | 'hex'): Promise<Buffer | undefined> | Promise<string | undefined>;
declare function useQuery<T extends QueryObject>(): Nullable<T>;
declare function useMethod(defaultMethod?: HTTPMethod): HTTPMethod;
declare function useCookies(): Record<string, string>;
declare function setCookie(name: string, value: string, serializeOptions?: any): void;
declare function sendRedirect(location: string, code?: number): Promise<void>;
declare function sendError(error: Error | H3Error): void;
declare function appendHeader(name: string, value: string): void;
declare function getHeader(name: string): string | string[] | undefined;
declare function assertMethod(expected: HTTPMethod | HTTPMethod[], allowHead?: boolean): void;
declare function isMethod(expected: HTTPMethod | HTTPMethod[], allowHead?: boolean): boolean;
declare function deleteCookie(name: string, serializeOptions?: any): void;

declare function setStatusCode(code: number): void;
declare function errorUnprocessableEntity(payload: any): any;
declare function errorNotFound(payload: any): any;

export { type ConfigPartial, type DeepPartial, type DeleteRoutes, type GetRoutes, type GroupAttributes, type HookResult, type HttpMethodInput, type NormaliseRouteFn, type Nullable$1 as Nullable, type OptionsRoutes, type PatchRoutes, type PostRoutes, type PutRoutes, type RegisterRouteFn, type ResolvedConfig, type ResolvedPlugin, type Route, type RouteMeta, type RouteSchema, type SimpleOptions, type UnroutedContext, type UnroutedEventHandler, type UnroutedHookable, type UnroutedHooks, type UnroutedMiddleware, type UnroutedPlugin, type UnroutedPreset, any, appendHeader, assertMethod, createUnrouted, defineConfig, defineUnroutedMiddleware, defineUnroutedPlugin, defineUnroutedPreset, del, deleteCookie, errorNotFound, errorUnprocessableEntity, get, getHeader, group, head, isMethod, match, middleware, normaliseRoute, options, permanentRedirect, post, prefix, put, readRawBody, redirect, registerRoute, resolveConfig, resolveStackPrefix, resolveStackRouteMeta, sendError, sendRedirect, setCookie, setStatusCode, unroutedEventHandler, useBody, useCookies, useEvent, useMethod, useParams, useQuery, useUnrouted };
